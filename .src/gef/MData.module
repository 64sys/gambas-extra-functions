' Gambas module file

' Gambas extra functions
' Compilation of utilities and functions developed by the gambas comunity.
'
' Copyright (C) Martín Belmonte.
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'
Public Sub getDBinfo(connDB As Connection) ''Extraccion de la informacion de la estructura de la base de datos

  Dim strSQLk As String
  Dim resDBk As Result
  Dim intR As Integer
  Dim strSentenceSQL As String
  Dim strSentence As String
  Dim stxSentence As New String[]
  Dim strTBOrigin As String
  Dim strFDOrigin As String
  Dim strTBReference As String
  Dim strFDReference As String
  Dim tblReference As Table
  Dim strFDShow As String
  Dim stxRefFields As New String[]
  Dim fldReference As Field
  Dim stxFDShowPK As New String[]
  Dim stxFDShow As New String[]
  Dim stxOrigin As New String[]
  Dim stxReference As New String[]
  Dim stxKeyWordsSQLite As New String[]
  Dim stxTypesSQLite As New String[]

  Select connDB.Type ' Tipo de motor de base de datos

    Case "sqlite3"
      stxKeyWordsSQLite.Add("not null")
      stxKeyWordsSQLite.Add("primary key")
      stxKeyWordsSQLite.Add("autoincrement")
      stxKeyWordsSQLite.Add("unique")
      stxKeyWordsSQLite.Add("default")

      stxTypesSQLite.Add("integer")
      stxTypesSQLite.Add("float")
      stxTypesSQLite.Add("real")
      stxTypesSQLite.Add("datetime")
      stxTypesSQLite.Add("varchar")
      stxTypesSQLite.Add("text")
      stxTypesSQLite.Add("bool")

      strSQLk = "SELECT * FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name" ' La letra K es por Key
      'resDBk = MData.SQLResult(connDB, strSQLk)
      resDBk = connDB.Exec(strSQLk)

      ' Creacion de la lista de tabla.campofk
      If connDB.Opened Then
        If resDBk.Available Then
          'Print "Foreign keys"
          For intR = 0 To resDBk.Max
            resDBk.MoveTo(intR)
            strTBOrigin = Str(resDBk["name"])

            strSentenceSQL = Str(resDBk["sql"])

            If InStr(strSentenceSQL, "FOREIGN KEY") <> 0 Then

              stxFDShow.Clear

              stxSentence = Split(strSentenceSQL, "\n")
              stxSentence = Mutility.ArrayInclude(stxSentence, "FOREIGN KEY")

              For Each strSentence In stxSentence
                If InStr(strSentence, "FOREIGN KEY") <> 0 Then

                  'Print strSentence
                  strSentence = Replace(strSentence, "\tFOREIGN KEY(`", "")
                  strSentence = Replace(strSentence, "`) REFERENCES ", "~")
                  strSentence = Replace(strSentence, " ( ", "~")
                  strSentence = Replace(strSentence, " ),", " )")
                  strSentence = Replace(strSentence, " )", "")
                  strSentence = Replace(strSentence, "`", "")
                  strSentence = Replace(strSentence, " ", "")

                  strFDOrigin = Split(strSentence, "~")[0]
                  strTBReference = Split(strSentence, "~")[1]
                  strFDReference = Split(strSentence, "~")[2]
                  ' Busco los campos de destino posibles

                  tblReference = connDB.Tables[strTBReference]
                  stxRefFields.Clear

                  If tblReference.Fields.Count > 1 Then

                    For Each fldReference In tblReference.Fields

                      stxRefFields.Add(fldReference.Name)

                    Next

                    If stxRefFields.Count > 1 Then
                      strFDShow = stxRefFields[1]
                    Else
                      strFDShow = strFDReference
                    Endif

                  Endif

                  stxOrigin.Add(strTBOrigin & "." & strFDOrigin)
                  stxReference.Add(strTBReference & "." & strFDReference & "." & strFDShow)
                  stxFDShow.Add(strFDShow)
                  stxFDShowPK.Add(strFDReference)

                Endif
              Next
            Endif
          Next
        Endif
      Endif
      'Case "postgres"
      'Case "mysql"
      'Case "odbc"

  End Select
  '---------------------------------------------------------------------------------

End

Public Function DBSqlite(stxDB As String[], Optional strMod As String) As Connection ''Inicia una base de datos o la crea y la inicia. Devuelve una conexion y como parametro de entrada requiere una matriz con los parametros de la base. Si la base de datos no existe, entonces crea una y la inicia.   ' Si la base de datos si existe, entonces puede hacer dos cosas, iniciarla o crear una copia de respaldo y crear una base nueva. stxDB contiene los paramentros de la base. 0 - DBHost. 1 - DBName. 2 - DBPath

  Dim conCreate As New Connection
  Dim strTimeStamp As String
  Dim strDBZip As String
  Dim strSQLCreate As String

  If conCreate.Opened Then
    conCreate.Close
  Endif

  strTimeStamp = MUtility.Timestamp(Now())

  strDBZip = File.Dir(stxDB[2]) &/ File.BaseName(stxDB[2]) & "-" & strTimeStamp & ".zip"

  Select strMod
    Case "reset"

      If Exist(stxDB[2]) = True Then
        Shell "zip -j " & strDBZip & " " & stxDB[2]
        Wait 0.5
        Kill stxDB[2]
      Endif
  End Select

  conCreate.Type = "sqlite3"
  conCreate.Host = stxDB[0]
  conCreate.Name = ""
  conCreate.Open

  If Not conCreate.Databases.Exist(stxDB[1]) Then
    conCreate.Databases.Add(stxDB[1])
    Wait 0.4

    If conCreate.Opened Then
      conCreate.Close
    Endif

    conCreate.Name = stxDB[1]
    conCreate.Open

    If Exist("new.sql") Then
      strSQLCreate = File.Load("new.sql")
      conCreate.Exec(strSQLCreate)
      Wait 0.4
      If conCreate.Opened Then
        conCreate.Close
      Endif

    Else
      Message.Warning(("No existe el archivo") & " " & "new.sql" & gb.NewLine & ("La base de datos no sera creada"))
    Endif
  Endif

  If conCreate.Opened Then
    conCreate.Close
  Endif

  Return conCreate

End

Public Function RecordNew(connDB As Connection, strTable As String, stxInsert As String[], stxValues As String[]) As Integer '' Inserta un registro nuevo en la base de datos, ctnVal es una coleccion opcional del pares de campo:valor.

  Dim resIns As Result
  Dim stxTables As New String[]
  Dim int As Integer
  Dim intTable As Integer
  Dim intField As Integer
  Dim strSQLCheck As String
  Dim resCheckRef As Result
  Dim intVal As Integer
  Dim stxTag As New String[]
  Dim stxVal As New String[]

  Dim strTag As String
  Dim strVal As String
  Dim intFKey As Integer
  Dim stxVKey As New String[]
  Dim intCounter As Integer

  If stxValues.Count > 0 Then
    For intVal = 0 To stxValues.Max
      stxTag.Add(Split(stxValues[intVal], ":")[0])
      stxVal.Add(Split(stxValues[intVal], ":")[1])
    Next
  Endif

  For int = 0 To stxInsert.Max
    If stxTables.Find(Split(stxInsert[int], ":")[0]) = -1 Then
      stxTables.Add(Split(stxInsert[int], ":")[0])
    Endif
  Next

  resIns = connDB.Create(strTable)
  For intField = 0 To stxInsert.Max
    If Split(stxInsert[intField], ":")[0] = strTable Then

      If Split(stxInsert[intField], ":")[6] <> "YA" Then

        strTag = Split(stxInsert[intField], ":")[1]
        intVal = stxTag.Find(strTag)
        If intVal > -1 Then
          strVal = stxVal[intVal]
        Else
          strVal = ""
        Endif

        Select Split(stxInsert[intField], ":")[7]
          Case ""
            resIns[strTag] = strVal
          Case Else

            For intCounter = 0 To 1

              strSQLCheck = "select "
              strSQLCheck &= Split(stxInsert[intField], ":")[8] & ", "
              strSQLCheck &= Split(stxInsert[intField], ":")[9]
              strSQLCheck &= " from " & Split(stxInsert[intField], ":")[7]
              strSQLCheck &= " where " & Split(stxInsert[intField], ":")[9] & "='"
              strSQLCheck &= strVal & "'"

              resCheckRef = connDB.Exec(strSQLCheck)

              If resCheckRef.Available Then
                intFKey = resCheckRef[Split(stxInsert[intField], ":")[8]]
                resIns[strTag] = intFKey
              Else

                Select intCounter
                  Case 0
                    stxVKey.Add(Split(stxInsert[intField], ":")[9] & ":" & strVal)

                    RecordRef(connDB, Split(stxInsert[intField], ":")[7], stxInsert, stxVKey)
                  Case Else
                    Message.Error("El registro no se pudo insertar")
                End Select

              Endif
            Next
        End Select
      Endif
    Endif
  Next
  resIns.Update

  'Comprobación de que el registro se creo correctamente

End

Public Function RecordWrite(connDB As Connection, strTable As String, stxEdit As String[], stxValues As String[]) As Integer '' Inserta un registro nuevo en la base de datos, ctnVal es una coleccion opcional del pares de campo:valor.

  Dim resEdit As Result
  Dim stxTables As New String[]
  Dim int As Integer
  Dim intTable As Integer
  Dim intField As Integer
  Dim strSQLCheck As String
  Dim resCheckRef As Result
  Dim intVal As Integer
  Dim stxTag As New String[]
  Dim stxVal As New String[]

  Dim strTag As String
  Dim strVal As String
  Dim intFKey As Integer
  Dim stxVKey As New String[]
  Dim intCounter As Integer
  Dim strFieldKey As String
  Dim intKey As Integer
  Dim intKeyRef As Integer

  For intField = 0 To stxEdit.Max
    If Split(stxEdit[intField], ":")[0] = strTable Then
      If Split(stxEdit[intField], ":")[5] = "YK" Then
        strFieldKey = Split(stxEdit[intField], ":")[1]
        Break
      Endif
    Endif
  Next

  If stxValues.Count > 0 Then
    For intVal = 0 To stxValues.Max
      stxTag.Add(Split(stxValues[intVal], ":")[0])
      stxVal.Add(Split(stxValues[intVal], ":")[1])
      If Split(stxValues[intVal], ":")[0] = strFieldKey Then
        intKey = CInt(Split(stxValues[intVal], ":")[1])
        'Break
      Endif
    Next
  Endif

  resEdit = connDB.Edit(strTable, strFieldKey & "=&1", intkey)

  For intField = 0 To stxEdit.Max
    If Split(stxEdit[intField], ":")[0] = strTable Then
      If Split(stxEdit[intField], ":")[1] <> strFieldKey Then
        strTag = Split(stxEdit[intField], ":")[1]
        intVal = stxTag.Find(strTag)
        If intVal > -1 Then
          strVal = stxVal[intVal]
        Else
          strVal = ""
        Endif

        Select Split(stxEdit[intField], ":")[7]
          Case ""
            If resEdit[strTag] <> strVal Then
              resEdit[strTag] = strVal
            Endif
          Case Else ' Verificar si el registro existe en la tabla foránea
            intKeyRef = RecordExist(connDB, Split(stxEdit[intField], ":")[7], Split(stxEdit[intField], ":")[9], Split(stxEdit[intField], ":")[8], strVal)
            Select intKeyRef
              Case -1 'No existe el registor de referencia
                stxVKey.Add(Split(stxEdit[intField], ":")[9] & ":" & strVal)
                RecordNew(connDB, Split(stxEdit[intField], ":")[7], stxEdit, stxVKey)
              Case Else ' Existe
                If resEdit[strTag] <> intKeyRef Then
                  resEdit[strTag] = intKeyRef
                Endif
            End Select
        End Select
      Endif
    Endif
  Next
  resEdit.Update

  'Comprobación de que el registro se creo correctamente

End

Public Function RecordRef(connDB As Connection, strTable As String, stxInsert As String[], stxValues As String[]) As Integer '' Inserta un registro nuevo en la base de datos, ctnVal es una coleccion opcional del pares de campo:valor.

  Dim resIns As Result
  Dim stxTables As New String[]
  Dim int As Integer
  Dim intTable As Integer
  Dim intField As Integer
  Dim strSQLCheck As String
  Dim resCheckRef As Result
  Dim intVal As Integer
  Dim stxTag As New String[]
  Dim stxVal As New String[]

  Dim strTag As String
  Dim strVal As String
  Dim intFKey As Integer
  Dim stxVKey As New String[]
  Dim intCounter As Integer

  If stxValues.Count > 0 Then
    For intVal = 0 To stxValues.Max
      stxTag.Add(Split(stxValues[intVal], ":")[0])
      stxVal.Add(Split(stxValues[intVal], ":")[1])
    Next
  Endif

  For int = 0 To stxInsert.Max
    If stxTables.Find(Split(stxInsert[int], ":")[0]) = -1 Then
      stxTables.Add(Split(stxInsert[int], ":")[0])
    Endif
  Next

  resIns = connDB.Create(strTable)
  For intField = 0 To stxInsert.Max
    If Split(stxInsert[intField], ":")[0] = strTable Then

      If Split(stxInsert[intField], ":")[6] <> "YA" Then

        strTag = Split(stxInsert[intField], ":")[1]
        intVal = stxTag.Find(strTag)
        If intVal > -1 Then
          strVal = stxVal[intVal]
        Else
          strVal = ""
        Endif

        Select Split(stxInsert[intField], ":")[7]
          Case ""
            resIns[strTag] = strVal

        End Select
      Endif
    Endif
  Next
  resIns.Update

End

Public Function getTableFields(connDB As Connection, strTab As String) As String[] ''Extraccion de la informacion de la estructura de una tabla.

  Dim strSQLk As String
  Dim resDBk As Result
  Dim intR As Integer
  Dim strSentenceSQL As String
  Dim strSentence As String
  Dim stxSentence As New String[]
  Dim stxOrigin As New String[]
  Dim stxReference As New String[]
  Dim strTBOrigin As String
  Dim strFDOrigin As String
  Dim strTBReference As String
  Dim strFDReference As String
  Dim tblReference As Table
  Dim strFDShow As String
  Dim stxRefFields As New String[]
  Dim fldReference As Field

  Dim stxFDShowPK As New String[]

  Dim tbl As Table
  Dim fld As Field
  Dim cntInfo As New Collection
  Dim strInfo As String
  Dim strkey As String
  Dim stxFieldInfo As New String[]
  Dim intSnt As Integer

  Dim stxWordsSQLite As New String[]
  Dim stxYesSQLite As New String[]
  Dim stxNotSQLite As New String[]
  Dim inxKeySQLite As New Integer[]
  Dim intWrd As Integer
  Dim intkey As Integer

  Dim stxTableInfo As New String[]

  Select connDB.Type

    Case "sqlite3"

      stxWordsSQLite.Add("unique")
      stxYesSQLite.Add("YU")
      stxNotSQLite.Add("NU")
      inxKeySQLite.Add(3)

      stxWordsSQLite.Add("not null")
      stxYesSQLite.Add("NN")
      stxNotSQLite.Add("YN")
      inxKeySQLite.Add(4)

      stxWordsSQLite.Add("primary key")
      stxYesSQLite.Add("YK")
      stxNotSQLite.Add("NK")
      inxKeySQLite.Add(5)

      stxWordsSQLite.Add("autoincrement")
      stxYesSQLite.Add("YA")
      stxNotSQLite.Add("NA")

      inxKeySQLite.Add(6)

      strSQLk = "SELECT * FROM sqlite_master WHERE type='table' AND name='" & strTab & "'"
      resDBk = connDB.Exec(strSQLk)
      strSentenceSQL = Str(resDBk["sql"])
      stxSentence = Split(strSentenceSQL, "\n")

      If connDB.Opened Then
        If resDBk.Available Then

          resDBk.MoveFirst

          tbl = connDB.Tables[strTab]

          For Each fld In tbl.Fields
            stxFieldInfo.Clear
            stxFieldInfo = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]

            stxFieldInfo[0] = strTab
            stxFieldInfo[1] = fld.Name
            stxFieldInfo[2] = String.LCase(MUtility.TypeVar(fld.Type))
            'stxFieldInfo[3] = ""
            'stxFieldInfo[4] = ""
            'stxFieldInfo[5] = ""
            'stxFieldInfo[6] = ""
            stxFieldInfo[7] = ""
            stxFieldInfo[8] = ""
            stxFieldInfo[9] = ""

            '----------------------------------------------------------------------------------
            For intSnt = 0 To stxSentence.Max
              If InStr(stxSentence[intSnt], "FOREIGN KEY") = 0 And InStr(stxSentence[intSnt], fld.Name) > 0 Then
                Print stxSentence[intSnt] & " Datos del campo"

                strSentence = Replace(stxSentence[intSnt], "\t`", "")
                strSentence = Replace(strSentence, fld.Name & "`", "")
                strSentence = Replace(strSentence, "\t", "")

                Print strSentence & " Datos del campo proc"

                For intWrd = 0 To stxWordsSQLite.Max

                  intkey = inxKeySQLite[intWrd]

                  If InStr(String.LCase(stxSentence[intSnt]), stxWordsSQLite[intWrd]) > 0 Then
                    stxFieldInfo[intkey] = stxYesSQLite[intWrd]
                  Else
                    stxFieldInfo[intkey] = stxNotSQLite[intWrd]
                  Endif
                Next

                Break
              Endif
            Next

            For intSnt = 0 To stxSentence.Max
              If InStr(stxSentence[intSnt], "FOREIGN KEY") > 0 And InStr(stxSentence[intSnt], fld.Name) > 0 Then
                Print stxSentence[intSnt] & " Datos del foráneo"

                strSentence = Replace(stxSentence[intSnt], "\tFOREIGN KEY(`", "")
                strSentence = Replace(strSentence, "`) REFERENCES ", "~")
                strSentence = Replace(strSentence, " ( ", "~")
                strSentence = Replace(strSentence, " ),", " )")
                strSentence = Replace(strSentence, " )", "")
                strSentence = Replace(strSentence, "`", "")
                strSentence = Replace(strSentence, " ", "")

                strFDOrigin = Split(strSentence, "~")[0]
                strTBReference = Split(strSentence, "~")[1]
                strFDReference = Split(strSentence, "~")[2]
                ' Busco los campos de destino posibles

                tblReference = connDB.Tables[strTBReference]
                stxRefFields.Clear

                If tblReference.Fields.Count > 1 Then

                  For Each fldReference In tblReference.Fields

                    stxRefFields.Add(fldReference.Name)

                  Next

                  If stxRefFields.Count > 1 Then
                    strFDShow = stxRefFields[1]
                  Else
                    strFDShow = strFDReference
                  Endif

                Endif

                stxFieldInfo[7] = strTBReference
                stxFieldInfo[8] = strFDReference
                stxFieldInfo[9] = strFDShow

                Break
              Endif
            Next
            '----------------------------------------------------------------------------------
            ' Agregando a la matriz de salida
            stxTableInfo.Add(stxFieldInfo.Join(":"))
          Next
        Endif
      Endif
      'Case "postgres"
      'Case "mysql"
      'Case "odbc"

  End Select
  '---------------------------------------------------------------------------------
  Return stxTableInfo

End

Public Function RecordExist(connDB As Connection, strTable As String, strFieldVal As String, strFieldKey As String, strValue As String) As Integer '' Devuelve -1 si no existe o un numero (la clave) si existe el texto que se pasa como parametro junto con la tabla y el campo.

  Dim strSQLCheck As String
  Dim resCheckRef As Result
  Dim intKey As Integer

  strSQLCheck = "select "
  strSQLCheck &= strFieldVal & ", " & strFieldKey
  strSQLCheck &= " from " & strTable
  strSQLCheck &= " where " & strFieldVal & "='"
  strSQLCheck &= strValue & "'"

  resCheckRef = connDB.Exec(strSQLCheck)

  If resCheckRef.Available Then
    If resCheckRef.Count > 0 Then
      intKey = resCheckRef[strFieldKey]
    Else
      intKey = -1
    Endif
  Endif
  Return intKey

End

Public Function RecordDelete(connDB As Connection, strTable As String, stxDBFields As String[], intKey As Integer) As Integer '' Devuelve -1 si no existe o un numero (la clave) si existe el texto que se pasa como parametro junto con la tabla y el campo.

  Dim strSQLDelete As String
  Dim resDelete As Result
  Dim resCheck As Result
  Dim intField As Integer
  Dim strFieldKey As String

  For intField = 0 To stxDBFields.Max
    If Split(stxDBFields[intField], ":")[0] = strTable Then
      If Split(stxDBFields[intField], ":")[5] = "YK" Then
        strFieldKey = Split(stxDBFields[intField], ":")[1]
        Break
      Endif
    Endif
  Next

  'resDelete = connDB.Delete(strTable, strFieldKey & "=&1", intKey)
  connDB.Delete(strTable, strFieldKey & "=&1", intKey)
  'resDelete.Update

  ' Verificación
  strSQLDelete = "select *"
  strSQLDelete &= " from " & strTable
  strSQLDelete &= " where " & strFieldKey & "='"
  strSQLDelete &= CStr(intKey) & "'"

  resCheck = connDB.Exec(strSQLDelete)

  If resCheck.Available Then
    If resCheck.Count > 0 Then
      intKey = resCheck[strFieldKey]
    Else
      intKey = -1
    Endif
  Else
    intKey = -1
  Endif

  Return intKey

End
