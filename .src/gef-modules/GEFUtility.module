' Gambas module file

' Gambas extra functions
' Armazón para contruir pogramas.
'
' Copyright (C) Martín Belmonte.
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Public Function DirParent(strPath As String) As String  ''Devuelve el directorio padre de otro que se pasa como parámetro.

  Dim strParent As String
  Dim intLast As Integer

  If strPath <> "" Then
    intLast = String.RInStr(strPath, "/")
    strParent = String.Mid(strPath, 1, intLast)
    If String.Len(strParent) > 1 Then
      If String.Right(strParent) = "/" Then
        strParent = String.Mid(strParent, 1, String.Len(strParent) - 1)

      Endif
    Endif
  Endif

  If Exist(strParent) = False Then
    strParent = "-1"
  Else
    If Stat(strParent).Type <> gb.Directory Then
      strParent = "-1"
    Endif
  Endif

  Return strParent

End

Public Function CodeStructure() As String[] ''Crea una matriz con las estructuras del lenguaje gambas que, por ejemplo, puede servir para iterpretar el código.

  Dim stxStructure As New String[]
  ' "X#Function #As " X es el primer caracter de comienzo de la línea de código

  stxStructure.Add("F#Function #Method Start")
  stxStructure.Add("S#Sub #Method Start")
  stxStructure.Add("S#Sub #) As #Method Start")
  stxStructure.Add("E#End#Method End")
  stxStructure.Add(" #Dim #As #Variable Local")
  stxStructure.Add("P#Public # As #Variable Public")
  stxStructure.Add("P#Private # As #Variable Private")
  stxStructure.Add("P#Public #Function #) As #Method Start")
  stxStructure.Add("P#Private #Function #) As #Method Start")
  stxStructure.Add("'#'#Commentary 1")
  stxStructure.Add("'#''#Commentary 2")
  stxStructure.Add("##Blank Line")
  stxStructure.Add(" #If #Then#Conditional structure Start")
  stxStructure.Add(" #If #Then #Break#Conditional structure Start-End")
  stxStructure.Add(" #Else#Conditional structure Middle")
  stxStructure.Add(" #Endif#Conditional structure End")
  stxStructure.Add(" #For #To #Loop Control Start")
  stxStructure.Add(" #For #To #Step #Loop Control Start")
  stxStructure.Add(" #For #Each #Loop Control Start")
  stxStructure.Add(" #For #Each #In #Loop Control Start")
  stxStructure.Add(" #Repeat#Loop Control Start")
  stxStructure.Add(" #Do #While #Loop Control Start")
  stxStructure.Add(" #While #Loop Control Start")
  stxStructure.Add(" #Do#Loop Control Start")

  stxStructure.Add(" #Continue#Loop Control Middle")
  stxStructure.Add(" #Next#Loop Control End")
  stxStructure.Add(" #Loop#Loop Control End")
  stxStructure.Add(" #Until#Loop Control End")
  stxStructure.Add(" #Wend#Loop Control End")

  stxStructure.Add(" #Inc #Increment")

  stxStructure.Add(" #Wait #Wait")

  stxStructure.Add(" #Select #Select Control Start")
  stxStructure.Add(" #Select Case #Select Control Start")
  stxStructure.Add(" #Case #Select Control Middle")
  stxStructure.Add(" #End Select#Select Control End")
  'Stream & Input/Output functions
  stxStructure.Add(" #Open # For Input#Open Stream")
  stxStructure.Add(" #Open # For Read#Open Stream")
  stxStructure.Add(" #Open # For Write#Open Stream")
  stxStructure.Add(" #Open # For Output#Open Stream")
  stxStructure.Add(" #Open # For Create#Open Stream")
  stxStructure.Add(" #Open # For Append#Open Stream")
  stxStructure.Add(" #Open # For Watch#Open Stream")
  stxStructure.Add(" #Print #Print")
  ' Faltan mas estructuras
  stxStructure.Add(" #Close #Close Stream")
  stxStructure.Add(" #Kill #Shell Command")
  stxStructure.Add(" #Shell #Shell Command")
  stxStructure.Add(" #Shell #To #Shell Command")
  stxStructure.Add(" #Move #Shell Command")
  stxStructure.Add(" #Copy #Shell Command")
  stxStructure.Add(" #Catch#Error Catch")
  stxStructure.Add(" #Try #Error Try")
  stxStructure.Add(" #Return #Method Middle")

  Return stxStructure

End

Public Function CodeTag(str As String) As String ''Analiza de una cadena de texto que se le pasa como parámetro y en el contexto de un fragmento de código, devuelve que es esa frase.

  Dim stxStruc As New String[]
  Dim stxSTmp As New String[]
  Dim stxCoin As New Integer[] 'Coincidencia
  'Dim intKey As Integer
  Dim int1 As Integer
  Dim int2 As Integer
  Dim int3 As Integer 'Coincidencia
  'Dim intRep As Integer
  'Dim int4 As Integer
  Dim inxCoin As New Integer[]
  Dim intCoin As Integer
  Dim strOutput As String
  Dim strType As String
  Dim strJob As String
  Dim stxSplitText As String[]
  'Dim strChar As String
  Dim strIsComment As String
  Dim intCh As Integer

  stxStruc = CodeStructure()
  stxCoin.Clear

  strJob = Replace(str, "  ", " ")
  strJob = Replace(strJob, " '", "'")

  Select strJob
    Case "", " ", "  ", "   "
      For int1 = 0 To stxStruc.Max
        If stxStruc[int1] = "##Blank Line" Then
          inxCoin.Add(1)
        Else
          inxCoin.Add(0)
        Endif
      Next

    Case Else

      If String.Mid(strJob, 1, 1) = " " Then
        ' verificar si es una linea comentada
        stxSplitText = GEFValidator.SplitText(strJob)
        strIsComment = "no"

        For intCh = 0 To stxSplitText.Max
          If stxSplitText[intCh] = " " Then
            Select intCh
              Case stxSplitText.Max
                'skip
              Case Else
                If stxSplitText[intCh + 1] = "'" Then
                  ' La fraase es un comentario
                  strIsComment = "yes"
                  Break
                Endif
            End Select

          Endif
        Next
        Select strIsComment
          Case "yes"
            strJob = "'c"
        End Select
      Endif

      For int1 = 0 To stxStruc.Max ' alrededor de 50 frases
        stxSTmp = Split(stxStruc[int1], "#")
        'File.Save(User .Home &/ "temp.txt", stxSTmp.Join("\t"))
        int3 = 0

        If String.Mid(strJob, 1, 1) = stxSTmp[0] Then
          For int2 = 1 To stxSTmp.Max - 1
            If InStr(strJob, stxSTmp[int2]) > 0 Then
              Inc int3
            Endif
          Next
          inxCoin.Add(int3)
        Else 'si la 1º letra no coincide > es 0, es decir no hay coincidencia
          inxCoin.Add(int3) ' en esta instancia int3 vale 0
        Endif
      Next
  End Select

  For intCoin = 0 To stxStruc.Max
    If inxCoin[intCoin] > 0 Then
      If inxCoin[intCoin] = ArrayMax(inxCoin) Then
        strType = Split(stxStruc[intCoin], "#")[Split(stxStruc[intCoin], "#").Max]
      Endif
      'strType = Split(stxStruc[intCoin], "#")[Split(stxStruc[intCoin], "#").Max]
      'Print strType
      'Break
    Endif
  Next

  Select strType
    Case ""
      strType = "Code"
  End Select

  'Select strType

  '  Case "Commentary 1"
  ' skip
  '  Case Else
  strOutput = strType & "\t" & str
  'End Select
  'strOutput = strType & "\t" & str

  Return strOutput

End

Public Function CodeMthod(stxPart As String[]) As String[]

  Dim intPart As Integer
  Dim stxFunc As New String[]
  Dim strFast As String
  Dim strMode As String
  Dim strScope As String
  'Dim strFunc As String
  Dim strType As String
  Dim strName As String
  Dim stxMethd As New String[]
  Dim strDesc As String
  Dim strRetn As String
  Dim strArgs As String
  Dim stxArgs As New String[]
  Dim strExtr As String
  Dim strTemp As String
  Dim intRetn As Integer
  Dim intDesc As Integer

  For intPart = 0 To stxPart.Max

    Select intPart
      Case 0
        strTemp = Split(stxPart[0], "\t")[1]

        stxFunc = Split(strTemp, " ")

        If stxFunc.Find("Fast") > -1 Then
          strFast = "Fast"
        Else
          strFast = ""
        Endif

        If stxFunc.Find("Static") > -1 Then
          strMode = "Static"
        Else
          strMode = ""
        Endif

        If stxFunc.Find("Public") > -1 Then
          strScope = "Public"
        Else
          If stxFunc.Find("Private") > -1 Then
            strScope = "Private"
          Else
            strScope = "Other"
          Endif
        Endif

        If stxFunc.Find("Function") > -1 Then
          strType = "Function"
        Else
          If stxFunc.Find("Procedure") > -1 Then
            strType = "Procedure"
          Else
            If stxFunc.Find("Sub") > -1 Then
              strType = "Sub"
            Endif
          Endif
        Endif
        strName = stxFunc[stxFunc.Max]
        ' ---------------
      Case 1
        strArgs = Replace(stxPart[1], ", ", "#")
        strArgs = Replace(strArgs, " As ", "~")
        If InStr(strArgs, "#") > 0 Then
          stxArgs = Split(strArgs, "#") ' intArg1>Integer#strArg2>String
        Else
          If InStr(strArgs, "~") > 0 Then
            stxArgs.Add(strArgs)
          Endif
        Endif
        ' ---------------
      Case 2
        strExtr = Replace(stxPart[2], " As ", "\tReturn: ")
        strExtr = Replace(strExtr, "''", "\tDescription: ")

        If InStr(strExtr, "\tReturn: ") > 0 Then
          intDesc = InStr(strExtr, "\tReturn: ")
          If intRetn > 0 Then
            strDesc = String.Mid(strExtr, intRetn + 9)
          Endif
        Else
          strRetn = ""
        Endif

        If InStr(strExtr, "\tDescription: ") > 0 Then
          intDesc = InStr(strExtr, "\tDescription: ")
          If intDesc > 0 Then
            strDesc = String.Mid(strExtr, intDesc + 14)
          Endif
        Else
          strDesc = ""
        Endif

    End Select
  Next

  stxMethd.Add(strFast) '
  stxMethd.Add(strMode) '
  stxMethd.Add(strScope) '
  stxMethd.Add(strType) '
  stxMethd.Add(strName) '
  stxMethd.Add(Replace(stxArgs.Join("/"), "~", " As "))
  stxMethd.Add(strRetn) '
  stxMethd.Add(strDesc) '

  Return stxMethd

End

Public Function RelationProj(stxClass As String[], stxMet As String[], stxCod As String[]) As String[] ''Lee las matrices de métodos y codigo del proyecto para luego analizar las relaciones entre estos generando una matrix con estas relaciones.

  'Dim int As Integer
  Dim stxReltn As New String[] ' Lista de métodos
  Dim intCod As Integer
  Dim intMet As Integer

  For intCod = 0 To stxCod.Max
    Print "// " & stxClass[intCod] & "." & stxMet[intCod]

    For intMet = 0 To stxMet.Max

      Select stxClass[intMet] = stxClass[intCod]
        Case True

          If InStr(stxCod[intCod], stxMet[intMet] & "(") > 0 Then
            stxReltn.Add(stxClass[intCod] & "." & stxMet[intCod] & "\t" & stxClass[intMet] & "." & stxMet[intMet])
          Else
            stxReltn.Add(stxClass[intMet] & "." & stxMet[intMet])
          Endif
        Case False

          If InStr(stxCod[intCod], stxClass[intMet] & "." & stxMet[intMet] & "(") > 0 Then
            stxReltn.Add(stxClass[intCod] & "." & stxMet[intCod] & "\t" & stxClass[intMet] & "." & stxMet[intMet])
          Else
            stxReltn.Add(stxClass[intMet] & "." & stxMet[intMet])
          Endif
      End Select

    Next
  Next
  If stxReltn.Count > 0 Then
    File.Save("/tmp" &/ "module-methode-relation.txt", stxReltn.Join("\n"))
    Wait 1
    Desktop.Open("/tmp" &/ "module-methode-relation.txt")
  Endif
  Return stxReltn

End

Public Function DokuProj(strPath As String) As String[] ''Lee todas las clases y los módulos de un proyecto gambas, recaba informacion del mismo de forma orenada y lo plasma en una matriz de texto.

  Dim stxFiles As New String[]
  Dim strFile As String
  Dim strFileExt As String
  Dim stxText As New String[]
  Dim int As Integer
  Dim intEnd As Integer
  Dim strFileBase As String
  Dim strType As String
  Dim intPlus As Integer
  Dim strMethod As String
  Dim strCode As String
  Dim stxCode As New String[]
  Dim stxVars As New String[]
  Dim stxPart As New String[]
  Dim stxMethod As New String[]
  Dim stxProj As New String[]
  Dim strTypeCode As String
  Dim intInit As Integer

  ' strPath Es el direcotrio raíz que se le pasa a la funcion, y a partir de allí
  ' esta buscara los archivos .project
  stxFiles = ScanDir(strPath)
  stxFiles.Sort

  If stxFiles.Count > 0 Then
    For Each strFile In stxFiles
      strFileExt = File.Ext(strFile)
      strFileBase = File.BaseName(strFile)
      Select strFileExt
        Case "module", "class"
          Print strFileBase
          stxText = FileLoadRaw(strFile)
          ' FileLoasRaw devuelve la matriz contemplando las lineas en blanco.
          'stxText = Replace(stxText, "\t", " ")  ' Reemplazo de tabuladores por espacios

          For int = 0 To stxText.Max
            intInit = int
            strMethod = CodeTag(Replace(stxText[int], "\t", " "))
            strType = Split(strMethod, "\t")[0]

            If strType = "Method Start" Then
              ' Resto del código
              stxPart = Split(strMethod, "()")
              stxMethod = CodeMthod(stxPart)

              intPlus = 1
              stxCode.Clear

              If int + intPlus <= stxText.Max Then

                Repeat

                  strCode = CodeTag(Replace(stxText[int + intPlus], "\t", " "))
                  strTypeCode = Split(strCode, "\t")[0]
                  Select strTypeCode
                    Case "Commentary 1", "Blank Line", "Method End"
                      'skip
                    Case "Variable Local"
                      stxVars.Add(Split(strCode, "\t")[1])
                      'skip
                    Case Else
                      stxCode.Add(Split(strCode, "\t")[1])
                  End Select

                  If (int + intPlus) < stxText.Max Then
                    Inc IntPlus
                  Endif
                  If strTypeCode = "Method End" Then
                    'int = int + intPlus
                    intEnd = int + intPlus
                    Break
                  Else
                    intEnd = int
                  Endif

                Until int + intPlus >= stxText.Max

              Endif
              'int = int + intPlus
              'Next

              ' Aca esta el método completo

              stxProj.Add(strFile & "\t" & strFileBase & "\t" & stxMethod.Join("\n") & "\t" & stxCode.Join("\n") & "\t" & stxVars.Join("\n") & "\t" & CStr(intInit) & "\t" & CStr(intEnd))
              'Print stxMethod.Join("\t") & strCode

            Endif
          Next
      End Select
    Next
  End If

  Return stxProj

End

Public Function CodeComment(str As String)

End

Public Function DokuHtml(strPath As String) As String ''Devuelve un html con las funciones de un módulo y todos los datos de estas, comoparametro de entrada requiere el directorio raiz a partir del cual buscar los módulos.

  Dim stxFiles As String[]
  Dim strHtml As String
  Dim strFile As String
  Dim strLine As String
  Dim intPub As Integer
  Dim strFunName As String
  Dim strFunParam As String
  Dim strFunReturn As String
  Dim strFunDesc As String
  Dim stxFunky As New String[]
  Dim intPrm As Integer
  Dim intQty As Integer

  Dim strKey As String
  Dim strAttr As String

  Dim stxInfo As New String[]
  Dim strFunCode As String

  stxInfo = GEFSys.ProjInfo()

  stxFiles = ScanDir(strPath)
  strKey = "Public Function "
  intPub = String.Len(strKey)
  ' Header
  strHtml &= "<!DOCTYPE html><html>"
  strHtml &= "<head>" ""
  strHtml &= "<meta charset=\"utf-8\"/>"
  strHtml &= "<meta name=\"description\"content=\" Wiki Of GEF " > " " ""
  strHtml &= "<meta name=\"keywords\"content=\"Gambas, GEF" > " " ""
  strHtml &= "<meta name=\"author\"content=\"" & stxInfo[2] & "\">"
  strHtml &= "<meta name=\"viewport\"content=\"width=device-width, initial-scale=1.0\">"
  strHtml &= "<title>" & Application.Name & "</title>"
  strHtml &= "</head><body>"
  strHtml &= "<style>.center {text-align: center;}</style>"
  strHtml &= "<div class=\"center\">"
  strHtml &= "<img src=\"./" & stxInfo[8] & "\" alt=\"Logo\" width=\"200\" height=\"200\">"
  strHtml &= "</div>"

  strHtml &= "<h1>" & Application.Name & "</h1>"
  strHtml &= "<p>" & ("Autor") & ": <b>" & stxInfo[2] & "</b></p>"
  strHtml &= "<p>" & ("Proveedor") & ": <b>" & stxInfo[3] & "</b></p>"
  strHtml &= "<p>" & ("Versión") & ": <b>" & stxInfo[4] & "</b></p>"
  strHtml &= "<p>" & ("Componentes") & ": <b>" & stxInfo[5] & "</b></p>"

  strHtml &= "<p>" & Application.Name & ("consta de") & " <b>FFUUNNCCIIOONNEESS</b> " & ("métdos") & "</p>"

  If stxFiles.Count > 0 Then
    For Each strFile In stxFiles
      If File.Ext(strFile) = "module" Then
        strHtml &= "<h2>" & File.Name(strFile) & "</h2>"
        Print "<h2> " & File.BaseName(strFile) & " </h2>"
        For Each strLine In FileLoad(strFile)
          If String.Left(strLine, intPub) = strKey Then
            Inc intQty

            strline = Replace(strline, strKey, "")
            strline = Replace(strline, "(", "\t")
            strline = Replace(strline, ") ", "\t")
            strline = Replace(strline, " ''", "\t")

            stxFunky.Clear
            stxFunky = Split(strline, "\t")

            Select stxFunky.Count
              Case 0
                strFunName = ""
                strFunParam = ""
                strFunReturn = ""
                strFunDesc = ""
                strFunCode = ""

              Case 2
                strFunName = stxFunky[0]
                strFunParam = stxFunky[1]
                strFunReturn = ""
                strFunDesc = ""
                strFunCode = ""

              Case 3
                strFunName = stxFunky[0]
                strFunParam = stxFunky[1]
                If String.len(stxFunky[2]) > 2 Then
                  If String.Mid(stxFunky[2], 1, 3) = "As " Then
                    strFunReturn = stxFunky[2]
                    strFunDesc = ""
                  Else
                    strFunReturn = ""
                    strFunDesc = stxFunky[2]
                  Endif
                Endif

              Case 4
                strFunName = stxFunky[0]
                strFunParam = stxFunky[1]
                strFunReturn = stxFunky[2]
                strFunDesc = stxFunky[3]

            End Select

            strHtml &= "<h3>" & strFunName & "</h3>"

            strFunParam = Replace(strFunParam, ", ", "\t")
            strFunParam = Replace(strFunParam, "Optional ", "Optional~")
            strFunParam = Replace(strFunParam, " As ", "#")

            If strFunParam <> "" Then
              strHtml &= "<ul>"
              For intPrm = 0 To Split(strFunParam, "\t").Count - 1

                strAttr = Split(Split(strFunParam, "\t")[intPrm], "#")[0]

                If InStr(strAttr, "Optional") > 0 Then
                  'strAttr = Split(strAttr, "~")[0] & Split(strAttr, "~")[1]
                  strHtml &= "<li><i>" & Split(strAttr, "~")[0] & "</i> <b>" & Split(strAttr, "~")[1] & "</b><i> As "
                Else
                  strHtml &= "<li><b>" & strAttr & "</b><i> As "
                Endif

                strHtml &= Split(Split(strFunParam, "\t")[intPrm], "#")[1] & "</i>" & "</li>"
              Next
              strHtml &= "</ul>"
            Endif

            strFunDesc = Replace(strFunDesc, "\n", "")
            strHtml &= "<p>" & strFunDesc & "</p>"
            'strHtml &= "<p>" & strFu & "</p>"

          Endif
        Next

      Endif
    Next
  Endif

  strHtml = Replace(strHtml, "FFUUNNCCIIOONNEESS", CStr(intQty))

  Return strHtml

End

Public Function DokuHtm2() As String ''Devuelve un html con las funciones de un módulo y todos los datos de estas, comoparametro de entrada requiere el directorio raiz a partir del cual buscar los módulos.

  Dim stxFiles As String[]
  Dim strHtml As String
  Dim strFile As String
  Dim strLine As String
  Dim intPub As Integer
  Dim strFunName As String
  Dim strFunParam As String
  Dim strFunReturn As String
  Dim strFunDesc As String
  Dim stxFunky As New String[]
  Dim intPrm As Integer
  Dim intQty As Integer

  Dim strKey As String
  Dim strAttr As String

  Dim stxInfo As New String[]
  Dim strFunCode As String

  Dim intFun As Integer
  Dim stxFun As New String[]
  Dim strCurrClass As String
  Dim stxCodeTmp As New String[]
  Dim intCodeTmp As Integer

  stxInfo = GEFSys.ProjInfo()

  'stxFiles = ScanDir(strPath)
  'strKey = "Public Function "
  'intPub = String.Len(strKey)
  ' Header
  strHtml &= "<!DOCTYPE html><html>"
  strHtml &= "<head>" ""
  strHtml &= "<meta charset=\"utf-8\"/>"
  strHtml &= "<meta name=\"description\"content=\"" & stxInfo[1] & "" > " " ""
  strHtml &= "<meta name=\"keywords\"content=\"" & stxInfo[3] & ", " & stxInfo[1] & "\">"
  'strHtml &= "<meta name=\"author\"content=\"" & stxInfo[2] & "\">"
  strHtml &= "<meta name=\"viewport\"content=\"width=device-width, initial-scale=1.0\">"
  strHtml &= "<title>" & Application.Name & "</title>"
  strHtml &= "</head><body>"
  'strHtml &= "<style>.center {text-align: center;}</style>"
  'strHtml &= "<div class=\"center\">"
  'strHtml &= "<img src=\"" & stxInfo[8] & "\" alt=\"Logo\" width=\"50\" height=\"50\">"
  'strHtml &= "</div>"

  'strHtml &= "<h1>" & Application.Name & "</h1>"
  strHtml &= "<p>" & ("Autor") & ": <b>" & stxInfo[2] & "</b></p>"
  strHtml &= "<p>" & ("Proveedor") & ": <b>" & stxInfo[3] & "</b></p>"
  strHtml &= "<p>" & ("Versión") & ": <b>" & stxInfo[4] & "</b></p>"
  strHtml &= "<h2>" & ("Componentes") & "</h2>"
  strHtml &= "<p>" & GEFWeb.ListHtml(stxInfo[5], ":") & "</p>"

  strHtml &= "<p>" & Application.Name & " " & ("consta de") & " <b>" & CStr(FMain.stxClass.Count) & "</b> " & ("métdos") & " </p>"

  'stxFun = GEFUtility.DokuProj(strPath)

  For intFun = 0 To FMain.stxClass.Max

    If FMain.stxClass[intFun] <> strCurrClass Then
      strHtml &= "<h2>" & FMain.stxClass[intFun] & "</h2>"
      strCurrClass = FMain.stxClass[intFun]
    Endif

    strHtml &= "<h3>" & FMain.stxName[intFun] & "</h3>"
    strHtml &= "<p>" & FMain.stxDesc[intFun] & "</p>"
    strHtml &= "<p>" & FMain.stxArgs[intFun] & "</p>"
    'strHtml &= "<p>" & FMain.stxVars[intFun] & "</p>"
    'stxCodeTmp.Clear
    'stxCodeTmp = Split(FMain.stxCode[intFun], "\n")
    'For intCodeTmp = 0 To stxCodeTmp.Max
    strHtml &= "<pre>" & FMain.stxCode[intFun] & "</pre>"
    'Next

    'strHtml &= "<code>" & Replace(FMain.stxCode[intFun], "\n", "</code><br>")

  Next
  ' 'FMain.stxClass
  ' FMain.stxFast
  ' FMain.stxMod
  ' FMain.stxScope
  ' FMain.stxType
  ' 'FMain.stxName
  ' 'FMain.stxArgs
  ' FMain.stxRetn
  ' 'FMain.stxDesc
  ' 'FMain.stxCode
  ' 'FMain.stxVars

  'Next

  Return strHtml

End

Public Function Dokuwiki(strPath As String) As String ''Devuelve un wiki con las funciones de un módulo y todos los datos de estas, comoparametro de entrada requiere el directorio raiz a partir del cual buscar los módulos.

  Dim stxFiles As String[]
  Dim strWiki As String
  Dim strFile As String
  Dim strLine As String
  Dim intPub As Integer
  Dim strFunName As String
  Dim strFunParam As String
  Dim strFunReturn As String
  Dim strFunDesc As String
  Dim stxFunky As New String[]
  Dim intPrm As Integer

  Dim strKey As String
  Dim i As Integer
  Dim intLine As Integer

  stxFiles = ScanDir(strPath)
  strKey = "Public Function "
  intPub = String.Len(strKey)

  If stxFiles.Count > 0 Then
    For Each strFile In stxFiles
      If File.Ext(strFile) = "module" Then
        strWiki &= "### " & File.Name(strFile)
        strWiki &= "\n"

        intLine = 0
        For Each strLine In FileLoad(strFile)
          If String.Left(strLine, intPub) = strKey Then

            strline = Replace(strline, strKey, "")
            strline = Replace(strline, "(", "\t")
            strline = Replace(strline, ") ", "\t")
            strline = Replace(strline, " ''", "\t")

            stxFunky.Clear
            stxFunky = Split(strline, "\t")

            Select stxFunky.Count
              Case 0
                strFunName = ""
                strFunParam = ""
                strFunReturn = ""
                strFunDesc = ""

              Case 2
                strFunName = stxFunky[0]
                strFunParam = stxFunky[1]
                strFunReturn = ""
                strFunDesc = ""

              Case 3
                strFunName = stxFunky[0]
                strFunParam = stxFunky[1]
                If String.len(stxFunky[2]) > 2 Then
                  If String.Mid(stxFunky[2], 1, 3) = "As " Then
                    strFunReturn = stxFunky[2]
                    strFunDesc = ""
                  Else
                    strFunReturn = ""
                    strFunDesc = stxFunky[2]
                  Endif
                Endif

              Case 4
                strFunName = stxFunky[0]
                strFunParam = stxFunky[1]
                strFunReturn = stxFunky[2]
                strFunDesc = stxFunky[3]

            End Select

            strWiki &= "*" & strFunName & "* " & " _" & strFunReturn & "_"
            strWiki &= "\n"

            strFunParam = Replace(strFunParam, ", ", "\t")
            strFunParam = Replace(strFunParam, "Optional ", "Opt.")
            strFunParam = Replace(strFunParam, " As ", "#")

            If strFunParam <> "" Then
              For i = 0 To Split(strFunParam, "\t").Count - 1
                strWiki &= CStr(intPrm + 1) & ". " & Split(Split(strFunParam, "\t")[intPrm], "#")[0] & " _" & Split(Split(strFunParam, "\t")[intPrm], "#")[1] & "_"
                strWiki &= "\n"
              Next

            Endif
            strWiki &= Replace(strFunDesc, "\n", "")
            strWiki &= "\n"

          Endif
          Inc intLine
        Next

      Endif
    Next
  Endif

  Return strWiki

End

Public Function FilesNew(strDirectory As String, Optional stxFilesOpt As String[], Optional strFilterOpt As String) As String[] ''Devuelve una lista de archivos de un directorio que se pasa como parametro. Opcionalmente se puede pasar como parametro una lista de archivos existentes los cuales seran omitidos de la lista de salida si es que son encontrados y un filtro de extensiones de archivo de l estilo mp3:ods:txt

  Dim stxFiles As New String[]
  Dim intFile As Integer
  Dim stxFilesNew As New String[] ' Archivos del directorio que existen en BBDD

  stxFiles = GEFUtility.ScanDir(strDirectory, strFilterOpt)

  'Para cada archivo verificar si este existe en la base de datos
  If stxFilesOpt.Count > 0 Then
    For intFile = 0 To stxFiles.Max
      If stxFilesOpt.Find(stxFiles[intFile]) = -1 Then
        stxFilesNew.Add(stxFiles[intFile])
      Endif
    Next
  Else ' Todos los archivos que se encuentren seran nuevos
    stxFilesNew = stxFiles
  Endif

  Return stxFilesNew

End

Public Function FilesExist(strDirectory As String, Optional stxFilesOpt As String[], Optional strFilterOpt As String) As String[] ''Devuelve una lista de archivos de un directorio que coinciden con los de la lista que se le pasa como parametro, es decir verifica que existen. Opcionalmente se le puede pasar un parametro de filtro de extensiones para acotar la busqueda.

  Dim stxFiles As New String[]
  Dim intFile As Integer
  Dim stxFilesExist As New String[] ' Archivos del directorio que existen en BBDD

  stxFiles = GEFUtility.ScanDir(strDirectory, strFilterOpt)

  'Para cada archivo verificar si este existe en la base de datos
  If stxFilesOpt.Count > 0 Then
    For intFile = 0 To stxFiles.Max
      If stxFilesOpt.Find(stxFiles[intFile]) > -1 Then
        stxFilesExist.Add(stxFiles[intFile])
      Endif
    Next
  Else
    stxFilesExist.Clear
  Endif

  Return stxFilesExist

End

Public Function FilesNone(strDirectory As String, Optional stxFilesOpt As String[], Optional strFilterOpt As String) As String[] ''Devuelve una lista de archivos que no existen en el directorio, es necesario parar una lista de archivos para contrastar.

  Dim stxFiles As New String[]
  Dim intFile As Integer
  Dim stxFilesNone As New String[] ' Archivos del directorio que existen en BBDD

  stxFiles = GEFUtility.ScanDir(strDirectory, strFilterOpt)

  'Para cada archivo verificar si este existe en la base de datos
  If stxFilesOpt.Count > 0 Then
    For intFile = 0 To stxFilesOpt.Max
      If stxFiles.Find(stxFilesOpt[intFile]) = -1 Then
        stxFilesNone.Add(stxFilesOpt[intFile])
      Endif
    Next
  Else
    stxFilesNone.Clear
  Endif

  Return stxFilesNone

End

Public Function FilesList(strPath As String) As String[] ''Devuelve una lista de archivos.

  Dim strPathsTmp As String
  Dim stxPaths As New String[]
  'Dim intP As Integer

  strPathsTmp = Replace(strPath, "\n", "")
  strPathsTmp = Replace(strPathsTmp, "\r", "")
  If String.Mid(strPath, 1, 7) = "file://" Then
    strPathsTmp = Right$(strPathsTmp, -7)  ' Quitando el primer "file://"
  Endif

  strPathsTmp = Replace(strPathsTmp, "file://", "\n") ' Este es por si existen mas de un archivo

  strPathsTmp = Replace(strPathsTmp, "\x00", "") 'un caracter que da problemas

  If InStr(strPathsTmp, "\n") Then
    stxPaths = Split(strPathsTmp, "\n")
  Else
    stxPaths.Add(strPathsTmp)
  Endif

  ' For intP = 0 To stxPaths.Max
  '   stxPaths[intP] = GEFUtility.ConvertPath(stxPaths[intP])
  ' Next

  Return stxPaths

End

Public Function FileNospace(stxParam As String[], Optional strDelim As String, Optional strExt As String) As String ''Devuelve un texto, nombre de arcivo concatenando todos los fragmentos que se le pase y pone todo en minusculas quita los caracteres fuera del rango 97-122 de ascci.

  Dim intPar As Integer
  Dim strTemp As String
  Dim intLeter As Integer
  Dim strLeter As String
  Dim strOutTmp As String
  Dim stxOutput As New String[]
  Dim strOutput As String

  If strDelim = "" Then
    strDelim = "#"
  Endif

  If strExt <> "" Then
    strExt = String.LCase(strExt)
    If InStr(strExt, ".") Then
      strExt = Replace(strExt, ".", "")
    Else
      strExt = "." & strExt
    Endif
  Endif

  If stxParam.Count > 0 Then
    For intPar = 0 To stxParam.Max

      strTemp = stxParam[intPar]
      strTemp = String.LCase(strTemp)
      strTemp = String.RemoveDiacritics(strTemp)
      strTemp = Replace(strTemp, "  ", Chr(45))
      strTemp = Replace(strTemp, "_", Chr(45))
      strTemp = Replace(strTemp, "--", Chr(45))
      strOutTmp = ""
      For intLeter = 1 To String.Len(strTemp)
        strLeter = String.Mid(strTemp, intLeter, 1)
        Select Asc(strLeter)
          Case Chr(32), Chr(45) ' Espacio o Gión
            strOutTmp &= "-"
          Case Else
            If Asc(strLeter) > 96 And Asc(strLeter) < 123 Then
              strOutTmp &= strLeter
            Endif
        End Select
      Next
      stxOutput.Add(strOutTmp)
    Next
  Endif

  strOutput = stxOutput.Join(strDelim) & strExt

  Return strOutput

End

Public Function FileVersion(strInputPath As String) As String ''Devuelve un texto con la versión del archivo que se le pasa como ruta. Usa el comando file de la terminal.

  Dim strVersion As String

  If InStr(strInputPath, "'") Then
    strInputPath = Replace(strInputPath, "'", "'\\''")
  Endif

  Shell "file '" & strInputPath & "'" To strVersion

  If InStr(strVersion, ":") <> 0 Then
    strVersion = Replace(strVersion, ": ", ":")
    strVersion = Split(strVersion, ":")[1]
    strVersion = ArrangePath(strVersion)
  Endif

  Return strVersion

End

Public Function FileLoad(strPath As String) As String[] ''Devuelve una matriz de texto donde cada ítem es un renglón del archivo de texto. Si el renglón esta vacio en el archivo de texto, es decir se trata de unallinea vacia, esta no se pasa a la martiz, por lo tanto el resultado es un retorno sin lineaas en blanco.

  Dim strList As String
  Dim stxListTmp As New String[]
  Dim stxList As New String[]
  Dim intList As Integer

  stxList.Clear

  If Exist(strPath) Then

    strList = File.Load(strPath)

    If InStr(strList, "\n") > -1 Then
      stxListTmp = Split(strList, "\n")
    Else
      If String.Len(strList) > 0 Then
        stxListTmp.Add(strList)
      Endif
    Endif

    For intList = 0 To stxListTmp.Max
      If stxListTmp[intList] <> "" Then
        stxList.Add(stxListTmp[intList])
      Endif
    Next
  Endif

  Return stxList

End

Public Function FileLoadRaw(strPath As String) As String[] ''Devuelve una matriz de texto donde cada ítem es un renglón del archivo de texto.

  Dim strList As String
  Dim stxListTmp As New String[]
  Dim stxList As New String[]
  Dim intList As Integer

  stxList.Clear

  If Exist(strPath) Then

    strList = File.Load(strPath)

    If InStr(strList, "\n") > -1 Then
      stxList = Split(strList, "\n")
    Else
      If String.Len(strList) > 0 Then
        stxList.Add(strList)
      Endif
    Endif
  Endif

  Return stxList

End

Public Function FileLog(strPath As String, strMsg As String) As String ''Agrega un la fecha actual y un texto que se pasa como parametro a un archivo log que tambien se pasa como parametro.

  Dim strText As String

  If strMsg <> "" Then
    If Exist(strPath) Then
      strText = File.Load(strPath)
    Else
      strText = ""
    End If
    strText = GEFUtility.Timestamp(Now()) & " " & strMsg & "\n" & strText
    File.Save(strPath, strText)
    Return strPath
  Else
    Return ""
  Endif

End

Public Function FileTemplate(strFileSeed As String, strFileProduct As String, stxTag As String[], stxDat As String[]) As String[] ''Tomando un archivo template reemplaza las etiquetas por valores. Retorna una matriz con una lista de archivos, primero el producto y luego el pdf, en cas que alguno de estos no exista en la posicion de la matriz hara una cadena vacia.

  Dim strTextProduct As String
  Dim intN As Integer
  Dim strFilePdf As String
  Dim prsTemp As Process
  Dim stxFilesOutput As String[]

  strFilePdf = File.Dir(strFileProduct) &/ File.BaseName(strFileProduct) & ".pdf"

  If Exist(strFileSeed) = True Then
    strTextProduct = File.Load(strFileSeed)

    If strTextProduct <> "" Then
      For intN = 0 To stxTag.Max

        strTextProduct = Replace(strTextProduct, stxTag[intN], stxDat[intN])

      Next

      File.Save(strFileProduct, strTextProduct)
      Wait 0.1

      prsTemp = Shell "dia " & strFileProduct & " -e " & strFilePdf
      While prsTemp.State = prsTemp.Running
        Wait 0.1
      Wend

    Endif

  Endif

  If Exist(strFileProduct) = True Then
    stxFilesOutput.Add(strFileProduct)
  Else
    stxFilesOutput.Add("")
  Endif

  If Exist(strFilePdf) = True Then
    stxFilesOutput.Add(strFilePdf)
  Else
    stxFilesOutput.Add("")
  Endif

  Return stxFilesOutput

End

Public Function FileReplace(strFileName As String, strSearch As String, strReplace As String) As Boolean ''Busca una cadena de texto en un archivo de entrada y la reemplaza por otra y luego pone todo en un archivo de salida. Archivos en modo input
  '----------------------------------------------------------------------
  'Creado por TercoIDE y formateado por Tincho
  'https://www.gambas-es.org/viewtopic.php?f=5&t=6056&start=10
  '----------------------------------------------------------------------

  Dim f As File
  Dim strFileOut As String
  Dim a As String
  Dim fo As File
  Dim b As String

  strFileOut = Mid$(strFileName, 1, Len(strFileName) - 3) & "tmp"

  Try Kill strFileOut

  f = Open strFileName For Input

  fo = Open strFileOut For Create

  Do
    Line Input #f, a
    '    Stop
    b = Replace(a, strSearch, strReplace)

    Write #fo, b & Chr$(13) & Chr$(10)
  Loop Until Eof(f)
  Close f
  Close fo

  Try Kill strFileName
  Try Move strFileOut To strFileName

  Return True

Catch
  Try Close f
  Try Close fo
  Return False

End Function

Public Function ArrangePath(strPathRaw As String) As String ''Devuelve una ruta sin los saltos del línea ni caracteres problemáticos

  Dim strPath As String

  strPath = Replace(strPathRaw, "\n", "")
  strPath = Replace(strPath, "\r", "")
  strPath = Replace(strPath, "\x00", "")

  Return strPath

End

Public Function FileCRC32(stInputPath As String, Optional strCase As String) As String ''Obtencion del crc32 de un archivo del que se pasa como parametro la ruta completa, como parametro opcional strCase puede ser U o L que parara todo a Ucase o Lcase.

  Dim strCrc32 As String

  Shell "crc32 '" & stInputPath & "'" To strCrc32

  strCrc32 = String.Mid(strCrc32, 1, 8) ' Corte de 8 caracters para quitar el \n y demas carcteres si se produjeran

  Select strCase
    Case "U", "u", ""
      strCrc32 = String.UCase(strCrc32)
    Case "L", "l"
      strCrc32 = String.LCase(strCrc32)
  End Select

  Return strCrc32

End

Public Function FileExifPages(strPath As String) As Integer ''Devuelve la cantidad de páginas del archivo si no tiene el tag entonces se devuelve 1. Para la extraccion de esta informacion se usa ExifTool.

  Dim strExifBruto As String
  Dim stxExifBruto As New String[]
  Dim intLin As Integer
  Dim intCur As Integer
  Dim intLen As Integer

  Dim intPages As Integer

  strPath = ArrangePath(strPath)

  Shell "exiftool -f -s -s '" & strPath & "' 2>&1" To strExifBruto ' Toma todos los tags del archivo

  stxExifBruto = Split(strExifBruto, "\n")

  For intLin = 0 To stxExifBruto.Max

    If stxExifBruto[intLin] <> "" Then
      intCur = InStr(stxExifBruto[intLin], ": ")
      intLen = String.Len(stxExifBruto[intLin])

      If String.Mid(stxExifBruto[intLin], 1, intCur - 1) = "PageCount" Then
        intPages = CInt(String.Mid(stxExifBruto[intLin], intCur + 2, intLen - intCur - 1))
        Break
      Else
        intPages = 1
      Endif

    Endif
  Next
  Return intPages

End

Public Function FileExifRaw(strPath As String) As String[] ''Devuelve una matriz con los metadatos extraídos por el programa de la terminal ExifTool.

  Dim strExifBruto As String
  Dim stxExifBruto As New String[]
  Dim intLin As Integer
  Dim intCur As Integer
  Dim intLen As Integer
  Dim strExifTag As String ' Nombre de la etiqueta exif
  Dim strExifVal As String ' Valor de la etiquieta
  Dim strExif As String
  Dim stxExif As New String[]

  Shell "exiftool -f -s -s '" & strPath & "' 2>&1" To strExifBruto ' Toma todos los tags del archivo

  stxExifBruto = Split(strExifBruto, "\n")

  For intLin = 0 To stxExifBruto.Max

    If stxExifBruto[intLin] <> "" Then
      intCur = InStr(stxExifBruto[intLin], ": ")
      intLen = String.Len(stxExifBruto[intLin])

      strExifTag = String.Mid(stxExifBruto[intLin], 1, intCur - 1)

      strExifVal = String.Mid(stxExifBruto[intLin], intCur + 2, intLen - intCur - 1)

      strExif = strExifTag & "\t" & strExifVal

      stxExif.Add(strExif)

    Endif
  Next
  Return stxExif

End

Public Function Timestamp(datTime As Date) As String ''Retorna una cadena de texto con el tiempo en formato "yyyymmddhhnnss".

  Return Format(datTime, "yyyymmddhhnnss")

End

Public Function TypeVar(intType As Integer) As String ''Función que devuelve el tipo de variable como una palabra. Como parametro de entrada requiere un numero entero.

  Dim vrxType As String[]

  vrxType = ["Null", "Boolean", "Byte", "Short", "Integer", "Long", "Single", "Float", "Date", "String", "Variant", "Object", "Pointer", "Function", "Class"]

  Return vrxType[intType]

End

Public Function MouseButton(intKey As Integer) As String ''Funcion que retorna el nombre en ingés del boton del ratón que se ha presionado.

  Dim strMouseButton As String

  Select intKey
    Case 1
      strMouseButton = "Left"
    Case 2
      strMouseButton = "Right"
    Case 4
      strMouseButton = "Center"
    Case 16
      strMouseButton = "Function-1"
    Case 8
      strMouseButton = "Function-2"
  End Select

  Return strMouseButton

End

Public Function ArrayInclude(stxList As String[], strFind As String) As String[] ''Quita de la lista los textos que no tengan la cadena de texto pasada como parametro

  Dim strItem As String
  Dim stxAuxiliar As New String[]

  stxAuxiliar.Clear

  For Each strItem In stxList
    If InStr(strItem, strFind) <> 0 Then

      stxAuxiliar.Add(strItem)

    Endif

  Next

  Return stxAuxiliar

End

Public Function ArrayMax(inx As Integer[]) As Integer ''Devuelve el maximo valor de lalista de numeros enteros.

  Dim int As Integer
  Dim intRet As Integer

  For Each int In inx

    If int > intRet Then
      intRet = int
    Endif

  Next

  Return intRet

End

Public Function ArrayExclude(stxList As String[], strFind As String) As String[] ''Quita de la lista los textos que tengan la cadena de texto pasada como parametro

  Dim strItem As String
  Dim stxAuxiliar As New String[]

  stxAuxiliar.Clear

  For Each strItem In stxList
    If InStr(strItem, strFind) = 0 Then

      stxAuxiliar.Add(strItem)

    Endif

  Next

  Return stxAuxiliar

End

Public Function FileInfo(strFilePath As String) As String[] ''Devuelve una matriz con datos del archivo que se le pasa como ruta.

  Dim stxFileMeta As New String[]
  Dim strFileDir As String
  Dim strFileName As String
  Dim strFileExt As String
  Dim strFileBase As String
  Dim strFileSize As String
  Dim strFileTime As String
  '  Dim strFileCRC32 As String
  Dim strFileVersion As String
  Dim strSep As String

  strFilePath = ArrangePath(strFilePath)
  strSep = "\t"

  If Stat(strFilePath).Type = gb.File Then
    ' Informacion básica para todo tipo de archivo

    stxFileMeta.Add("FilePath" & strSep & strFilePath)

    strFileDir = File.Dir(strFilePath)
    stxFileMeta.Add("FileDirectory" & strSep & strFileDir)

    strFileName = File.Name(strFilePath)
    stxFileMeta.Add("FileName" & strSep & strFileName)

    strFileExt = File.Ext(strFilePath)
    stxFileMeta.Add("FileExt" & strSep & strFileExt)

    strFileBase = File.BaseName(strFilePath)
    stxFileMeta.Add("FileBase" & strSep & strFileBase)

    strFileSize = Stat(strFilePath).Size
    stxFileMeta.Add("FileSize" & strSep & strFileSize)

    strFileTime = GEFUtility.Timestamp(Stat(strFilePath).Time)
    strFileTime = Replace(strFileTime, ":", ".")
    stxFileMeta.Add("FileTime" & strSep & strFileTime)

    ' strFileCRC32 = GEFUtility.CRC32(strFilePath)
    ' stxFileMeta.Add("FileCRC32" & strSep & strFileCRC32)

    strFileVersion = GEFutility.FileVersion(strFilePath)
    strFileVersion = Replace(strFileVersion, ":", ".")
    stxFileMeta.Add("FileVersion" & strSep & strFileVersion)

  Endif

  Return stxFileMeta

End

Public Function NamingCon() As String[] ''Devuelve una lista de nombres de controles y su abreviación de tres caracteres.

  Dim stxNCon As New String[]

  stxNCon.Add("Bolean:bol")
  stxNCon.Add("ButtonBox:bto")
  stxNCon.Add("Button:btn")
  stxNCon.Add("CheckBox:cko")
  stxNCon.Add("Collection:ctn")
  stxNCon.Add("ColorButton:cob")
  stxNCon.Add("ColorChooser:coc")
  stxNCon.Add("ColorPalette:cop")
  stxNCon.Add("ColumnView:cuw")
  stxNCon.Add("ComboBox:cmo")
  stxNCon.Add("Connection:con")
  stxNCon.Add("Control:crl")
  stxNCon.Add("DataBase:dbs")
  stxNCon.Add("DataBrowser:dbw")
  stxNCon.Add("DataCombo:dcm")
  stxNCon.Add("DataComboView:dcv")
  stxNCon.Add("DataControl:dcr")
  stxNCon.Add("DataSource:dsr")
  stxNCon.Add("DateBox:dto")
  stxNCon.Add("DateChooser:dtc")
  stxNCon.Add("Date:dat")
  stxNCon.Add("Date[]:dtx")
  stxNCon.Add("Dial:dal")
  stxNCon.Add("DirBox:dio")
  stxNCon.Add("DirChooser:dic")
  stxNCon.Add("DirView:diw")
  stxNCon.Add("DocumentView:dcw")
  stxNCon.Add("DrawingArea:dra")
  stxNCon.Add("Editor:edi")
  stxNCon.Add("Expander:exn")
  stxNCon.Add("FileChooser:fic")
  stxNCon.Add("Fileld:fld")
  stxNCon.Add("FileProperties:fii")
  stxNCon.Add("FileView:fiw")
  stxNCon.Add("Float:flo")
  stxNCon.Add("Float[]:flx")
  stxNCon.Add("FontBox:fno")
  stxNCon.Add("FontChooser:fnc")
  stxNCon.Add("Frame:fra")
  stxNCon.Add("GambasEditor:gbe")
  stxNCon.Add("GridView:grw")
  stxNCon.Add("Hbox:hzo")
  stxNCon.Add("Hpanel:hzn")
  stxNCon.Add("Hsplit:hzs")
  stxNCon.Add("IconPanel:icn")
  stxNCon.Add("IconView:icw")
  stxNCon.Add("ImageView:imw")
  stxNCon.Add("InputBox:ito")
  stxNCon.Add("Integer:int")
  stxNCon.Add("Integer[]:inx")
  stxNCon.Add("Label:lbl")
  stxNCon.Add("LCDlabel:lcd")
  stxNCon.Add("ListBox:lso")
  stxNCon.Add("ListEditor:lse")
  stxNCon.Add("ListView:lsw")
  stxNCon.Add("MaskBox:mko")
  stxNCon.Add("MenuButton:mub")
  stxNCon.Add("MessageView:mgw")
  stxNCon.Add("MovieBox:mio")
  stxNCon.Add("Object:obj")
  stxNCon.Add("Panel:pnl")
  stxNCon.Add("PictureBox:pio")
  stxNCon.Add("Picture:pic")
  stxNCon.Add("Printer:ptr")
  stxNCon.Add("Process:prs")
  stxNCon.Add("ProgressBar:psr")
  stxNCon.Add("RadioButton:rdb")
  stxNCon.Add("Result:res")
  stxNCon.Add("ScrollArea:sca")
  stxNCon.Add("ScrollBar:scr")
  stxNCon.Add("ScrollView:scw")
  stxNCon.Add("Separator:sep")
  stxNCon.Add("SidePanel:sdn")
  stxNCon.Add("SliderBox:sdo")
  stxNCon.Add("Slider:sld")
  stxNCon.Add("SpinBox:sio")
  stxNCon.Add("Spiner:sir")
  stxNCon.Add("String:str")
  stxNCon.Add("String[]:stx")
  stxNCon.Add("SwitchButton:swb")
  stxNCon.Add("Table:tbl")
  stxNCon.Add("TableView:tbw")
  stxNCon.Add("TabPanel:tan")
  stxNCon.Add("TabStrip:tat")
  stxNCon.Add("TextArea:txa")
  stxNCon.Add("TextBoxExplained:teo")
  stxNCon.Add("TextBox:txo")
  stxNCon.Add("TextEdit:txe")
  stxNCon.Add("TextLabel:txl")
  stxNCon.Add("TextList:tlo")
  stxNCon.Add("TextView:txw")
  stxNCon.Add("Timer:tmr")
  stxNCon.Add("ToggleButton:tgb")
  stxNCon.Add("ToolButton:tob")
  stxNCon.Add("ToolPanel:ton")
  stxNCon.Add("TreeView:trw")
  stxNCon.Add("URLLabel:url")
  stxNCon.Add("ValueBox:vao")
  stxNCon.Add("Variant:vrt")
  stxNCon.Add("Variant[]:vrx")
  stxNCon.Add("Vbox:veo")
  stxNCon.Add("Vpanel:ven")
  stxNCon.Add("Vsplit:ves")
  stxNCon.Add("Wizard:wiz")

  Return stxNCon

End

Public Function HMStoSeconds(strTime As String) As Integer ''Devuelve el tiempo en segundos de una cadena que se le pase con el formato HH:MM:SS HORAS:MINUTOS:SEGUNDOS.

  Dim stxTime As New String[]
  Dim intTime As Integer

  stxTime = Split(strTime, ":")

  intTime = (stxTime[0] * 3600) + (stxTime[1] * 60) + stxTime[2]

  Return intTime

End

Public Function SecondsToHMS(intTime As Integer) As Integer[] ''Devuelve el tiempo en una matriz donde: 0-Y 1-M 2-D 3-H 4-N 5-S y como parametro de entrada requiere el tiempo en segundos

  Dim intH As Integer ' Horas
  Dim intN As Integer ' Minutos
  Dim intS As Integer ' Segundos
  Dim stxTime As New String[]

  Select intTime / 3600
    Case 0
      intH = 0
    Case 1
      intH = 1
      intN = 0
    Case Else
      intH = intTime / 3600

      Select (intTime Mod 3600) Mod 60
        Case 0
          intN = (intTime Mod 3600) / 60
          intS = 0
        Case Else
          intN = (intTime Mod 3600) / 60
          intS = (intTime Mod 3600) Mod 60

      End Select
  End Select

  stxTime.Add(intH)
  stxTime.Add(intN)
  stxTime.Add(intS)

  Return stxTime

End

Public Function MkConfXml(strXmlPath As String) As Integer ''Creacion de archivo de configuracion inicial xml.

  Dim writer As New XmlWriter
  Dim stxParameters As New String[]
  Dim intE As Integer
  Dim stxAtrib As New String[]
  Dim intA As Integer

  stxParameters.Add("MediaFolder:Path")
  stxParameters.Add("CapitalMode:Mode")
  stxParameters.Add("LangCurr:Name")
  stxParameters.Add("Languages:Name")
  stxParameters.Add("Software:Name:Seed:Prod")

  'Apertura del documento
  writer.Open(strXmlPath, True) 'True es para que le ponga los saltos de linea
  writer.StartElement(Application.Name)

  'Creación de una entidad
  For intE = 0 To stxParameters.Max
    stxAtrib.Clear
    stxAtrib = Split(stxParameters[intE], ":")

    writer.StartElement(stxAtrib[0])
    If stxAtrib.Count > 1 Then
      For intA = 1 To stxAtrib.Max
        writer.StartElement(stxAtrib[intA])
        writer.Text("")
        writer.EndElement
      Next
    Endif
    writer.EndElement
  Next

  writer.EndElement

  writer.EndDocument

  Return 1

End

Public Function ListDeldup(stxInput As String[]) As String[] ''Elimina elementos duplicados de una lista, requiere una String[] y devuelve una String[].

  Dim strTmp As String
  Dim stxOut As New String[]

  stxInput.Sort

  For Each strTmp In stxInput
    If stxOut.Find(strTmp) = -1 Then
      stxOut.Add(strTmp)
    Endif
  Next

  Return stxOut

End

Public Function WhereRun() As Integer ''Indica si el programa se esta ejecutando desde el IDE o desde un ejecutable solo utilizando código de gambas.

  Dim strProcess As String
  Dim intRun As Integer

  strProcess = File.Load("/proc" &/ CStr(Application.Id) &/ "comm")

  If Left(strProcess, 4) = "gbx3" Then

    intRun = 1
  Else
    intRun = 0
  Endif

  Return intRun

End

Public Function RListDir(strPath As String) As String[] ''Devuelve una lista de directorios que se encuentran en la ruta que se pasa como parametro.

  Dim stxTmp As New String[]
  Dim stxDirs As New String[]
  Dim strDir As String

  Select Stat(strPath).Type
    Case gb.File
      stxTmp = RDir(File.Dir(strPath), "*", gb.Directory)
    Case gb.Directory
      stxTmp = RDir(strPath, "*", gb.Directory)
  End Select
  For Each strDir In stxTmp
    stxDirs.Add(strPath &/ strDir)
  Next

  Return stxDirs

End

Public Function DirGambas(strPath As String) As Boolean ''Analiza si el directorio que se le pasa como paramentro de entrada es un direcotio de un proyecto gambas.

  Dim strGambas As String

  strGambas = ""

  ' Hay que acertar en todo para dar el ok
  If Exist(strPath &/ ".project") = True Then
    strGambas = "g"
    If Exist(strPath &/ ".settings") = True Then
      strGambas &= "a"
      If Exist(strPath &/ ".startup") = True Then
        strGambas &= "m"
        If Exist(strPath &/ ".src") = True Then
          strGambas &= "b"
          If Exist(strPath &/ ".hidden") = True Then
            strGambas &= "a"
            If Exist(strPath &/ ".gitignore") = True Then
              strGambas &= "s"
            Endif
          Endif
        Endif
      Endif
    Endif
  Endif

  If strGambas = "gambas" Then
    Return True
  Else
    Return False
  Endif

End

Public Function ScanDir(strDir As String, Optional strExt As String) As String[] ''Escanea un directorio que se pasa como parametro en busca de archivos se puede filtrar con una lista de extensiones separadas por dos puntos ":".

  Dim stxFiles As New String[]
  Dim stxExt As New String[]

  Dim intE As Integer
  Dim intR As Integer

  Dim strFileRaw As String
  Dim strFilePro As String
  Dim intA As Integer

  If IsDir(strDir) = True Then

    If strExt = "" Then

      stxFiles = RDir(strDir)

    Else
      If InStr(strExt, ":") <> 0 Then

        strExt = String.LCase(strExt)

        stxExt = Split(strExt, ":")

        If stxExt.Count > 1 Then

          For intE = 0 To stxExt.Max
            Select intE
              Case 0

                stxFiles = RDir(strDir, "*." & stxExt[intE])

              Case Else

                stxFiles.Insert(RDir(strDir, "*." & stxExt[intE]))

            End Select

          Next

        Endif

      Else
        stxFiles = RDir(strDir, "*." & strExt, True)
      Endif

    Endif

  Endif

  stxFiles.Sort

  For intA = 0 To stxFiles.Max

    stxFiles[intA] = strDir &/ stxFiles[intA]

  Next

  For intR = 0 To stxFiles.Max

    strFileRaw = stxFiles[intR]

    If Stat(strFileRaw).Type = gb.File Then
      strFilePro = GEFValidator.ConvertPath(strFileRaw)
      strFilePro = GEFData.Chek4SQL(strFilePro)

      If strFileRaw <> strFilePro Then

        Try Copy strFileRaw To strFilePro

        Wait 0.3
        If Exist(strFilePro) = True Then
          stxFiles[intR] = strFilePro
          Kill strFileRaw
        Else
          Message.Info(("El archivo") & " " &
            gb.NewLine & strFileRaw &
            gb.NewLine &
            ("Tiene caracteres no compatibles con") & " ascii")
        Endif

      Endif
    Endif

  Next

  Return stxFiles

End
