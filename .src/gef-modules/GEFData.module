' Gambas module file

' Gambas extra functions
' Compilation of utilities and functions developed by the gambas comunity.
'
' Copyright (C) Martín Belmonte.
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Public Function DBTemplate(stxDB As String[]) As String ''Crea una plantilla de la base de datos que se le pasa como parametros.

  Dim conCreate As New Connection
  Dim strTemplate As String

  conCreate.Type = stxDB[0]
  conCreate.Host = stxDB[1]
  conCreate.Name = stxDB[2]

  conCreate.Open
  strTemplate = conCreate.GetTemplate()
  conCreate.Close

  Return strTemplate

End

Public Function DBViewsTitles() As String[][] ''Esta funcion se debe modificar para cada plantilla de base de datos, o estructura de base de datos (no para cada motor). Es devuelta una matriz de texto de 3 dimensiones de la forma Tabla|Vista//Titulo-de-Tabla|Vista//Icono donde Titulo-de-Tabla|Vista es un texto que como se ve en el código esta entre parentesis ("") y ello permite que se puedan traducir con la aplicacion, prestando asi una versatilidad mayor y haciendo que el programa sea mas amigable.

  Dim stxVTitles As New String[][]
  ' // Carga de vistas y tablas, y se debe modificar cuando se use otra estructura de BBDD

  stxVTitles.Add(["view_jobs", ("Trabajos"), "icon:/16/add"])
  stxVTitles.Add(["view_boms", ("Materiales y tareas"), "icon:/16/add"])
  stxVTitles.Add(["view_codes", ("Códigos"), "icon:/16/add"])
  stxVTitles.Add(["view_composites", ("Compuestos"), "icon:/16/add"])
  stxVTitles.Add(["view_deliverables", ("Informes"), "icon:/16/add"])
  stxVTitles.Add(["view_logistics", ("Logística"), "icon:/16/add"])
  stxVTitles.Add(["view_owners", ("Clientes"), "icon:/16/add"])
  stxVTitles.Add(["view_suppliers", ("Suministradores"), "icon:/16/add"])
  stxVTitles.Add(["view_uoms", ("Unidades de medida"), "icon:/16/add"])

  Return stxVTitles

End

Public Function DBFieldsTitles() As String[][] ''Esta funcion se debe modificar para cada plantilla de base de datos, o estructura de base de datos (no para cada motor). Es devuelta una matriz de texto de 3 dimensiones de la forma Tabla|Vista//Nombre-de-campo//Titulo-de-campo donde Titulo-de-campo es un texto que como se ve en el código esta entre parentesis ("") y ello permite que los titulos de los campos se puedan traducir con la aplicacion, prestando asi una versatilidad mayor y haciendo que el programa sea mas amigable.

  Dim stxFTitles As New String[][]
  ' // Carga de vistas y tablas, y se debe modificar cuando se use otra estructura de BBDD

  stxFTitles.Add(["boms", "midx", ("Índice")])
  stxFTitles.Add(["boms", "mjob", ("Trabajo")])
  stxFTitles.Add(["boms", "mcod", ("Código")])
  stxFTitles.Add(["boms", "mqty", ("Cantidad")])

  stxFTitles.Add(["view_boms", "midx", ("Índice")])
  stxFTitles.Add(["view_boms", "mjob", ("Trabajo")])
  stxFTitles.Add(["view_boms", "mcod", ("Código")])
  stxFTitles.Add(["view_boms", "mclass", ("Clase")])
  stxFTitles.Add(["view_boms", "mqty", ("Cantidad")])
  stxFTitles.Add(["view_boms", "mprice", ("Precio")])
  stxFTitles.Add(["view_boms", "muom", ("Unidad")])
  stxFTitles.Add(["view_boms", "msupplier", ("Suministrador")])

  stxFTitles.Add(["codcls", "sidx", ("Índice")])
  stxFTitles.Add(["codcls", "sname", ("Clase")])

  stxFTitles.Add(["codes", "cidx", ("Índice")])
  stxFTitles.Add(["codes", "cname", ("Insumo")])
  stxFTitles.Add(["codes", "cclass", ("Clase")])
  stxFTitles.Add(["codes", "cqty", ("Cantidad")])
  stxFTitles.Add(["codes", "cuom", ("Unidad")])
  stxFTitles.Add(["codes", "cprice", ("Precio")])

  stxFTitles.Add(["view_codes", "cidx", ("Índice")])
  stxFTitles.Add(["view_codes", "cname", ("Insumo")])
  stxFTitles.Add(["view_codes", "cclass", ("Clase")])
  stxFTitles.Add(["view_codes", "cqty", ("Cantidad")])
  stxFTitles.Add(["view_codes", "cuom", ("Unidad")])
  stxFTitles.Add(["view_codes", "cprice", ("Precio")])

  stxFTitles.Add(["composites", "aidx", ("Índice")])
  stxFTitles.Add(["composites", "aname", ("Compuesto")])
  stxFTitles.Add(["composites", "adesc", ("Descripción")])

  stxFTitles.Add(["view_composites", "aidx", ("Índice")])
  stxFTitles.Add(["view_composites", "aname", ("Compuesto")])
  stxFTitles.Add(["view_composites", "adesc", ("Descripción")])

  stxFTitles.Add(["deliverables", "didx", ("Índice")])
  stxFTitles.Add(["deliverables", "dname", ("Informe")])

  stxFTitles.Add(["view_deliverables", "didx", ("Índice")])
  stxFTitles.Add(["view_deliverables", "dname", ("Informe")])

  stxFTitles.Add(["jobs", "jidx", ("Índice")])
  stxFTitles.Add(["jobs", "jname", ("Trabajo")])
  stxFTitles.Add(["jobs", "jdate", ("Fecha")])
  stxFTitles.Add(["jobs", "jowner", ("Cliente")])
  stxFTitles.Add(["jobs", "jlogistic", ("Logística")])

  stxFTitles.Add(["view_jobs", "jidx", ("Índice")])
  stxFTitles.Add(["view_jobs", "jname", ("Trabajo")])
  stxFTitles.Add(["view_jobs", "jdate", ("Fecha")])
  stxFTitles.Add(["view_jobs", "jowner", ("Cliente")])
  stxFTitles.Add(["view_jobs", "jlogistic", ("Logística")])

  stxFTitles.Add(["logistics", "lidx", ("Índice")])
  stxFTitles.Add(["logistics", "lname", ("Logística")])

  stxFTitles.Add(["view_logistics", "lidx", ("Índice")])
  stxFTitles.Add(["view_logistics", "lname", ("Logística")])

  stxFTitles.Add(["owners", "oidx", ("Índice")])
  stxFTitles.Add(["owners", "oname", ("Cliente")])
  stxFTitles.Add(["owners", "ophone", ("Fijo")])
  stxFTitles.Add(["owners", "omovile", ("Móvil")])
  stxFTitles.Add(["owners", "oaddress", ("Dirección")])
  stxFTitles.Add(["owners", "ocity", ("Ciudad")])

  stxFTitles.Add(["view_owners", "oidx", ("Índice")])
  stxFTitles.Add(["view_owners", "oname", ("Cliente")])
  stxFTitles.Add(["view_owners", "ophone", ("Fijo")])
  stxFTitles.Add(["view_owners", "omovile", ("Móvil")])
  stxFTitles.Add(["view_owners", "oaddress", ("Dirección")])
  stxFTitles.Add(["view_owners", "ocity", ("Ciudad")])

  stxFTitles.Add(["suppliers", "fidx", ("Índice")])
  stxFTitles.Add(["suppliers", "fname", ("Suministrador")])
  stxFTitles.Add(["suppliers", "fphone", ("Fijo")])
  stxFTitles.Add(["suppliers", "fmovile", ("Móvil")])
  stxFTitles.Add(["suppliers", "faddress", ("Dirección")])
  stxFTitles.Add(["suppliers", "fcity", ("Ciudad")])

  stxFTitles.Add(["view_suppliers", "fidx", ("Índice")])
  stxFTitles.Add(["view_suppliers", "fname", ("Suministrador")])
  stxFTitles.Add(["view_suppliers", "fphone", ("Fijo")])
  stxFTitles.Add(["view_suppliers", "fmovile", ("Móvil")])
  stxFTitles.Add(["view_suppliers", "faddress", ("Dirección")])
  stxFTitles.Add(["view_suppliers", "fcity", ("Ciudad")])

  stxFTitles.Add(["uoms", "uidx", ("Índice")])
  stxFTitles.Add(["uoms", "uname", ("Magnitud")])
  stxFTitles.Add(["uoms", "usymbol", ("Simbolo")])

  stxFTitles.Add(["view_uoms", "uidx", ("Índice")])
  stxFTitles.Add(["view_uoms", "uname", ("Magnitud")])
  stxFTitles.Add(["view_uoms", "usymbol", ("Simbolo")])

  Return stxFTitles

End

Public Function DBOpen(stxDB As String[]) As Connection ''Inicia una base de datos y si no existe la crea.

  Dim con As New Connection
  Dim str As String
  Dim tbl As Table
  Dim fld As Field

  Dim strTbN As String  ' Nombre de tabla
  Dim strFdN As String  ' Nombre de campo
  Dim strFdT As String  ' Tipo de campo
  Dim strTbR As String  ' Tabla de referencia
  Dim strFdRi As String ' Campo clave de referencia
  Dim strFdRs As String ' Campo a mostrar de la tabla dereferencia

  con.Type = stxDB[0]
  con.Host = stxDB[1]
  con.Name = stxDB[2]
  con.Port = stxDB[3]
  con.User = stxDB[4]
  con.Password = stxDB[5]

  Select con.Type

    Case "sqlite3"
      'Averiguar si la base de datos existe, que en el caso de sqlite3 es un archivo.sqlite
      If Exist(con.Host &/ con.Name) Then
        con.Open
        For Each tbl In con.Tables
          strTbN = tbl.Name
          'Next
          Print "Table name: " & strTbN

          For Each fld In tbl.Fields

            strFdN = fld.Name

            If tbl.PrimaryKey.Find(fld.Name) <> -1 Then ' ¿El campo es clave primaria de la tabla?
              strFdT = DataType(-1)
            Else
              strFdT = DataType(fld.Type)
            Endif
            strTbR = ""
            strFdRi = ""
            strFdRs = ""

            Print "Field data > Name[" & strFdN & "] Type[" & strFdT & "]"

          Next
        Next
      Else ' No existe el archivo
        con.Name = "" ' Especifico un nombre vacio para poder abrir luego
        con.Open
        con.Databases.Add(stxDB[2]) ' Agrego la base de datos nueva
        con.Close
        con.Name = stxDB[2] ' Cambio el nombre de la base de datos a la recientemente creada
        con.Open
        str = File.Load("db.template") ' Cargo la plantilla
        con.ApplyTemplate(str) ' Aplico la plantilla a la nueva base.

      Endif

    Case "sqlite2"

    Case "sqlite"

    Case "odbc"

    Case "postgresql"

    Case "mysql"

  End Select

  Return con

End

Public Function DBSqlite(stxDB As String[], Optional strMod As String) As Connection ''Inicia una base de datos o la crea y la inicia. Devuelve una conexion y como parametro de entrada requiere una matriz con los parametros de la base. Si la base de datos no existe, entonces crea una y la inicia.   ' Si la base de datos si existe, entonces puede hacer dos cosas, iniciarla o crear una copia de respaldo y crear una base nueva. stxDB contiene los paramentros de la base. 0 - DBHost. 1 - DBName. 2 - DBPath

  Dim conCreate As New Connection
  Dim strTimeStamp As String
  Dim strDBZip As String
  Dim strSQLCreate As String
  '  Dim strTemplate As String

  If conCreate.Opened Then
    conCreate.Close
  Endif

  strTimeStamp = GEFUtility.Timestamp(Now())

  strDBZip = File.Dir(stxDB[3]) &/ File.BaseName(stxDB[3]) & "-" & strTimeStamp & ".zip"

  conCreate.Type = stxDB[0]
  conCreate.Host = stxDB[1]
  conCreate.Name = ""
  conCreate.Open

  Select strMod
    Case "reset"

      If Exist(stxDB[3]) = True Then
        Shell "zip -j " & strDBZip & " " & stxDB[3]
        Wait 0.5
        Kill stxDB[3]
      Endif
  End Select

  Wait 0.2

  Select strMod
    Case "empty"
      If Not conCreate.Databases.Exist(stxDB[2]) Then
        conCreate.Databases.Add(stxDB[2])
      Endif

      'Case Else
    Case "new"

      If Not conCreate.Databases.Exist(stxDB[2]) Then
        conCreate.Databases.Add(stxDB[2])
      Endif
      'If Exist("new.sql") Then
      If Exist("db.template") Then
        'strSQLCreate = File.Load("new.sql")
        strSQLCreate = File.Load("db.template")
        'strSQLCreate = Chek4SQLscript(strSQLCreate)
        'strSQLCreate = Replace(strSQLCreate, "BEGIN TRANSACTION;", "")
        'strSQLCreate = Replace(strSQLCreate, "COMMIT;", "")

        'conCreate.Exec(strSQLCreate)
        'strTemplate = conCreate.GetTemplate(strSQLCreate)
        'conCreate.Open
        'conCreate.Databases.Add(stxDB[2])

        conCreate.ApplyTemplate(strSQLCreate)

      Else
        Message.Warning(("No existe el archivo") & " " & "new.sql" & gb.NewLine & ("La base de datos no sera creada"))
      Endif
  End Select

  If conCreate.Opened Then
    conCreate.Close
  Endif

  Return conCreate

End

Public Function RecordNew(connDB As Connection, strTable As String, stxDBFields As String[][], stxValues As String[]) As Integer ''Inserta un registro nuevo en la base de datos. Si este es insertado correctamente la funcion devuelve la clave de dicho registro, de lo contratio devuelve -1

  Dim resIns As Result
  Dim stxTables As New String[]
  Dim int As Integer
  Dim intField As Integer
  Dim strSQLCheck As String
  Dim resCheckRef As Result
  Dim intVal As Integer
  Dim stxTag As New String[]
  Dim stxVal As New String[]

  Dim strTag As String
  Dim strVal As String
  Dim intFKey As Integer
  Dim stxVKey As New String[]
  Dim intCounter As Integer

  Dim intKey As Integer

  Dim strSqlExist As String
  Dim resExist As Result
  Dim intExist As Integer
  Dim stxSqlExistFields As New String[]
  Dim stxSqlExistWhere As New String[]

  Dim strFieldKey As String
  Dim intRefKey As String

  For intExist = 0 To stxValues.Max
    If Split(stxValues[intExist], "\t")[1] <> "" Then

      stxSqlExistFields.Add(Split(stxValues[intExist], "\t")[0])

      intRefKey = RecordForeign(connDB, strTable, Split(stxValues[intExist], "\t")[0], Split(stxValues[intExist], "\t")[1], stxDBFields)

      Select intRefKey
        Case -1 ' No es un campo referenciado
          stxSqlExistWhere.Add(Split(stxValues[intExist], "\t")[0] & "='" & Split(stxValues[intExist], "\t")[1] & "'")
        Case -2 'El campo es referenciado pero la tabla de referencia no contiene el texto, por lo tanto luego se agregara, y como no hay peligro de repetir el registro se continua
          Print "El registro no existe, en la tabla de referencia"
        Case -3  'El campo es referenciado pero la tabla de referencia contiene mas de una coincidencia, por lo tanto debe revisarse la estructura de la tabla.
          stxSqlExistWhere.Add(Split(stxValues[intExist], "\t")[0] & "='" & intRefKey & "'")
        Case Else ' este es el caso ideal, donde el texto existe en la referencia, es único y por lo tanto se devuelve la clave en la tabla de referencia
          stxSqlExistWhere.Add(Split(stxValues[intExist], "\t")[0] & "='" & intRefKey & "'")

      End Select

    Endif
  Next

  strSqlExist = "select " & stxSqlExistFields.Join(",") & " from " & strTable
  strSqlExist &= " where " & stxSqlExistWhere.Join(" and ")

  resExist = connDB.Exec(strSqlExist)

  If resExist.Available Then
    If resExist.Count > 0 Then
      Print "El registro ya existe"
      'Message.Info("El registro ya existe")
    Endif

  Else

    Print "El registro no existe, se procede a insertarlo"

    If stxValues.Count > 0 Then
      For intVal = 0 To stxValues.Max
        stxTag.Add(Split(stxValues[intVal], "\t")[0])
        stxVal.Add(Split(stxValues[intVal], "\t")[1])
      Next
    Endif

    For int = 0 To stxDBFields.Max
      If stxTables.Find(stxDBFields[int][0]) = -1 Then
        stxTables.Add(stxDBFields[int][0])
      Endif
    Next

    resIns = connDB.Create(strTable)
    For intField = 0 To stxDBFields.Max
      If stxDBFields[intField][0] = strTable Then

        If stxDBFields[intField][6] <> "YA" Then

          strTag = stxDBFields[intField][1]
          intVal = stxTag.Find(strTag)
          If intVal > -1 Then
            strVal = stxVal[intVal]
          Else
            strVal = ""
          Endif

          Select stxDBFields[intField][7]
            Case ""
              resIns[strTag] = strVal
            Case Else
              If strVal <> "" Then
                For intCounter = 0 To 1

                  strSQLCheck = "select "
                  strSQLCheck &= stxDBFields[intField][8] & ", "
                  strSQLCheck &= stxDBFields[intField][9]
                  strSQLCheck &= " from " & stxDBFields[intField][7]
                  strSQLCheck &= " where " & stxDBFields[intField][9] & "='"
                  strSQLCheck &= strVal & "'"

                  resCheckRef = connDB.Exec(strSQLCheck)

                  If resCheckRef.Available Then
                    intFKey = resCheckRef[stxDBFields[intField][8]]
                    resIns[strTag] = intFKey
                  Else
                    Select intCounter
                      Case 0
                        stxVKey.Add(stxDBFields[intField][9] & "\t" & strVal)
                        RecordNewRef(connDB, stxDBFields[intField][7], stxDBFields, stxVKey)
                      Case Else
                        Message.Error("El registro no se pudo insertar")
                    End Select

                  Endif
                Next
              Endif
          End Select
        Endif
      Endif
    Next
    resIns.Update

    'Comprobación de que el registro se creo correctamente
    stxSqlExistWhere.Clear
    stxSqlExistFields.Clear

    For intExist = 0 To stxValues.Max
      If Split(stxValues[intExist], "\t")[1] <> "" Then

        stxSqlExistFields.Add(Split(stxValues[intExist], "\t")[0])

        intRefKey = RecordForeign(connDB, strTable, Split(stxValues[intExist], "\t")[0], Split(stxValues[intExist], "\t")[1], stxDBFields)

        Select intRefKey
          Case -1 ' No es un campo referenciado
            stxSqlExistWhere.Add(Split(stxValues[intExist], "\t")[0] & "='" & Split(stxValues[intExist], "\t")[1] & "'")
          Case Else ' este es el caso ideal, donde el texto existe en la referencia, es único y por lo tanto se devuelve la clave en la tabla de referencia
            stxSqlExistWhere.Add(Split(stxValues[intExist], "\t")[0] & "='" & intRefKey & "'")
        End Select
      Endif
    Next

    strSqlExist = ""
    strSqlExist = "select " & stxSqlExistFields.Join(",") & " from " & strTable
    strSqlExist &= " where " & stxSqlExistWhere.Join(" and ")

    resExist = connDB.Exec(strSqlExist)

    If resExist.Available Then
      If resExist.Count > 0 Then
        Print "El registro fue insertado correctamente"

        intKey = resExist[strFieldKey]

      Else
        Print "El registro no fue insertado o un valor no fue asignado correctamente a alguno de los campos"
        intKey = -1
      Endif
    Endif

  Endif

  Return intKey

End

Public Function RecordKey(strTable As String, stxDBFields As String[][]) As String ''Devuelve el nombre del campo clave de la tabla. connDB As Connection es laq conxión a la base de  datos. strTable As String es el nombre de la tabla sobre la que intenta saber que tipo de campo es. strFieldCheck As String Es el campo a verificar. strValueCheck As String Es el valor del registro para el campo a verificar. stxDBFields As String[] Es la lista de todos los campos de la base de datos.

  Dim intIndex As Integer
  Dim strFieldKey As String

  For intIndex = 0 To stxDBFields.Max
    If stxDBFields[intIndex][0] = strTable Then
      If stxDBFields[intIndex][6] = "YA" Then
        strFieldKey = stxDBFields[intIndex][1]
        Break
      Endif
    Endif
  Next
  Return strFieldKey

End

Public Function RecordForeign(connDB As Connection, strTable As String, strFieldCheck As String, strValueCheck As String, stxDBFields As String[][]) As String ''Devuelve la clave en la tabla foránea para un valor de texto si el campo es referenciado o -1 si el campo no es referenciado o no existe el valor en el campo a mostrar.

  Dim intIndex As Integer
  Dim intForeign As Integer

  Dim strForeignTable As String
  Dim strForeignIndex As String
  Dim strForeignShow As String
  Dim strSqlForeign As String
  Dim resForeign As Result

  For intIndex = 0 To stxDBFields.Max
    If stxDBFields[intIndex][0] = strTable Then
      If stxDBFields[intIndex][1] = strFieldCheck Then
        strForeignTable = stxDBFields[intIndex][7]
        strForeignIndex = stxDBFields[intIndex][8]
        strForeignShow = stxDBFields[intIndex][9]
        Break
      Endif
    Endif
  Next

  Select strForeignTable
    Case ""
      intForeign = -1
    Case Else

      strSqlForeign = "select " & strForeignIndex & " from " & strForeignTable
      strSqlForeign &= " where " & strForeignShow & "='" & strValueCheck & "' order by " & strForeignIndex & " asc"

      resForeign = connDB.Exec(strSqlForeign)

      If resForeign.Available Then
        Select resForeign.Count
          Case 0
            intForeign = -2
          Case 1
            resForeign.MoveFirst
            intForeign = CInt(resForeign[strForeignIndex])
          Case Else
            intForeign = -3
            Message.Warning(("Existen") & " " & CStr(resForeign.Count) &
              " " & ("coincidencias, debería ser una sola") &
              gb.NewLine & ("Se utilizara el primero de la lista"))
        End Select

      Endif

  End Select

  Return intForeign

End

' Public Function RecordWrite(connDB As Connection, strTable As String, stxEdit As String[][], stxValues As String[]) As Integer ''Inserta un registro nuevo en la base de datos, ctnVal es una coleccion opcional del pares de campo:valor.
'
'   Dim resEdit As Result
'   Dim intField As Integer
'   Dim intVal As Integer
'   Dim stxTag As New String[]
'   Dim stxVal As New String[]
'
'   Dim strTag As String
'   Dim strVal As String
'   Dim stxVKey As New String[]
'   Dim strFieldKey As String
'   Dim intKey As Integer
'   Dim intKeyRef As Integer
'
'   For intField = 0 To GEFStarter.stxTableFields.Max
'     If GEFStarter.stxTableFields[intField][0] = strTable Then
'       If GEFStarter.stxTableFields[intField][5] = "YK" Then
'         strFieldKey = GEFStarter.stxTableFields[intField][1]
'       Endif
'     Endif
'   Next
'
'   If stxValues.Count > 0 Then
'     For intVal = 0 To stxValues.Max
'       stxTag.Add(Split(stxValues[intVal], ":")[0])
'       stxVal.Add(Split(stxValues[intVal], ":")[1])
'       If Split(stxValues[intVal], ":")[0] = strFieldKey Then
'         intKey = CInt(Split(stxValues[intVal], ":")[1])
'         'Break
'       Endif
'     Next
'   Endif
'
'   resEdit = connDB.Edit(strTable, strFieldKey & "=&1", intkey)
'
'   For intField = 0 To stxEdit.Max
'     If stxEdit[intField][0] = strTable Then
'       If stxEdit[intField][1] <> strFieldKey Then
'         strTag = stxEdit[intField][1]
'         intVal = stxTag.Find(strTag)
'         If intVal > -1 Then
'           strVal = stxVal[intVal]
'         Else
'           strVal = ""
'         Endif
'
'         Select stxEdit[intField][7]
'           Case ""
'             If resEdit[strTag] <> strVal Then
'               resEdit[strTag] = strVal
'             Endif
'
'           Case Else ' Verificar si el registro existe en la tabla foránea
'             If strVal <> "" Then
'               intKeyRef = RecordExist(connDB, stxEdit[intField][7], stxEdit[intField][9], stxEdit[intField][8], strVal)
'               Select intKeyRef
'                 Case -1 'No existe el registor de referencia
'                   stxVKey.Add(stxEdit[intField][9] & ":" & strVal)
'                   RecordNew(connDB, stxEdit[intField][7], stxEdit, stxVKey)
'                 Case Else ' Existe
'                   If resEdit[strTag] <> intKeyRef Then
'                     resEdit[strTag] = intKeyRef
'                   Endif
'               End Select
'             Endif
'         End Select
'       Endif
'     Endif
'   Next
'   resEdit.Update
'
'   'Comprobación de que el registro se creo correctamente
'
' End

Public Function RecordNewRef(connDB As Connection, strTable As String, stxDBFields As String[][], stxValues As String[]) As Integer ''Inserta un registro nuevo en la base de datos, ctnVal es una coleccion opcional del pares de campo:valor.

  Dim resIns As Result
  Dim stxTables As New String[]
  Dim int As Integer
  Dim intField As Integer
  Dim intVal As Integer
  Dim stxTag As New String[]
  Dim stxVal As New String[]

  Dim strTag As String
  Dim strVal As String

  If stxValues.Count > 0 Then
    For intVal = 0 To stxValues.Max
      stxTag.Add(Split(stxValues[intVal], "\t")[0])
      stxVal.Add(Split(stxValues[intVal], "\t")[1])
    Next
  Endif

  For int = 0 To stxDBFields.Max
    If stxTables.Find(stxDBFields[int][0]) = -1 Then
      stxTables.Add(stxDBFields[int][0])
    Endif
  Next

  resIns = connDB.Create(strTable)
  For intField = 0 To stxDBFields.Max
    If stxDBFields[intField][0] = strTable Then

      If stxDBFields[intField][6] <> "YA" Then

        strTag = stxDBFields[intField][1]
        intVal = stxTag.Find(strTag)
        If intVal > -1 Then
          strVal = stxVal[intVal]
        Else
          strVal = ""
        Endif

        Select stxDBFields[intField][7]
          Case ""
            resIns[strTag] = strVal

        End Select
      Endif
    Endif
  Next
  resIns.Update

End

Public Function getFields(connDB As Connection, strTbl As String, strMod As String, Optional stxFTitles As String[][]) As String[][] ''Extraccion de la lista de campos de la tabla que se pasa como parametro.

  Dim strSQL As String
  Dim resSQL As Result
  Dim fld As ResultField

  Dim strFld As String
  Dim strTyp As String

  Dim strOrd As String
  Dim strFty As String
  Dim strFva As String
  Dim strFwd As String
  Dim strFs1 As String
  Dim strFs2 As String
  Dim strFs3 As String
  Dim strTle As String

  Dim stxTmp As New String[][]
  Dim stxExt As New String[]
  Dim stxFld As New String[][]
  Dim intTl As Integer

  strSQL = "select * from " & strTbl
  resSQL = connDB.Exec(strSQL)
  If resSQL Then

    For Each fld In resSQL.Fields

      strFld = fld.Name
      strTyp = String.LCase(GEFUtility.TypeVar(fld.Type))

      If stxFTitles Then
        For intTl = 0 To stxFTitles.Max
          If stxFTitles[intTl][0] = strTbl Then
            If stxFTitles[intTl][1] = strFld Then
              strTle = stxFTitles[intTl][2]
            Endif
          Endif
        Next
      Endif

      Select String.LCase(strMod)
        Case "table", "tables", "tabla", "tablas"
          stxExt = getFieldInfo(connDB, strTbl, strFld)

          stxTmp.Add([strTbl, strFld, strTyp, stxExt[0], stxExt[1], stxExt[2], stxExt[3], stxExt[4], stxExt[5], stxExt[6], strTle])

        Case "view", "views", "vista", "vistas"

          strOrd = Settings[strTbl & "-Order" &/ strFld, ""] ' Orden
          strFty = Settings[strTbl & "-FilterType" &/ strFld, ""] ' Filtro Tipo
          strFva = Settings[strTbl & "-FilterValue" &/ strFld, ""] ' Filtro Valor
          strFwd = Settings[strTbl & "-Width" &/ strFld, "75"] ' Ancho de Columna
          strFs1 = "" ' Reserva 1 > Funcion especial, email, informe, etc.
          strFs2 = "" ' Reserva 2 >
          strFs3 = "" ' Reserva 3 >
          'strTle = "" ' Titles

          stxTmp.Add([strTbl, strFld, strTyp, strOrd, strFty, strFva, strFwd, strFs1, strFs2, strFs3, strTle])

      End Select

      stxFld.Insert(stxTmp)

      stxTmp.Clear
      stxExt.Clear

    Next
  Endif

  Return stxFld

End

Public Function GetForeignKey(strValue As String, conRef As Connection, strTable As String, strFieldKey As String, strFieldName As String) As Integer ''Devuelve la clave del registro referenciado en otra tabla

  Dim intKey As Integer
  Dim strSQLForeign As String
  Dim resFeoreign As Result
  Dim stxForeignKey As New String[]
  Dim stxForeignName As New String[]
  Dim intCounter As Integer
  Dim resInsert As Result

  intKey = -1
  intCounter = 0

  Repeat

    stxForeignKey.Clear
    stxForeignName.Clear

    strSQLForeign = "select " & strFieldKey & ", " & strFieldName & " from " & strTable

    resFeoreign = conRef.Exec(strSQLForeign)

    While resFeoreign.Available

      stxForeignKey.Add(resFeoreign[strFieldKey])
      stxForeignName.Add(resFeoreign[strFieldName])

      If strValue = resFeoreign[strFieldName] Then
        intKey = resFeoreign[strFieldKey]
        Break
      Endif

      resFeoreign.MoveNext

    Wend

    If intKey = -1 Then ' Quiere decir que ese nombre no esta en la tabla de referencia, entonces hay que insertarlo

      resInsert = conRef.Create(strTable)

      resInsert[strFieldName] = strValue

      resInsert.update

    Endif

  Until intKey <> -1

  Return intKey

End

Public Function AskForField(strTable As String, stxFields As String[][]) As String[] ''Devuelve informacion sobre el campo que se pregunta, devuelve una matriz con 10 valores de texto. Se le pasan el nombre de la tabla el campo y una matriz de 2 Dimensiones con tod ala informacion en bruto que genera la función getFiles().</br>Depende de si es una tabla o una vista:</br>Tabla:</br>00 TableName \ n01 FieldName[ From gb.db]</br>02 FieldType[ From gb.db]</br>03 Unique[YU |NU]</br>04 Null / Not Null[YN |NN]</br>05 Primary Key[YK |NK]</br>06 Autoincrement[YA |NA]</br>07 ForeignTableName</br>08 ForeignFieldIndexName</br>09 ForeignFieldShowName</br>Vista:</br>00 ViewName</br>01 FieldName[ From gb.db]</br>02 FieldType[ From gb.db]</br>03 Order["asc" | "desc" | ""]</br>04 Filter Type["=" / "<>" | ">"/"<" | ">="/"<=" | "like"/"not like" | "in" ]</br>05 Filter Value</br>06 Width</br>07 Spare > Future For Functions</br>08 Spare</br>09 Spare

  Dim stxInfo As New String[]
  Dim intY As Integer
  Dim intX As Integer

  For intX = 0 To stxFields.Max
    If stxFields[intX][0] = strTable Then
      For intY = 0 To 9
        stxInfo.Add(stxFields[intX][intY])
      Next
    Endif
  Next

  Return stxInfo

End

Public Function Chek4SQLscript(strInput As String) As String ''Devuelve un texto apto para consulatas SQL, quita los saltos del línea y los caracteres no compatibles con sentencias SQL.

  Dim strOutput As String

  strOutput = Replace(strInput, "\n", "")
  strOutput = Replace(strOutput, "\r", "")
  strOutput = Replace(strOutput, "\t", " ")
  strOutput = Replace(strOutput, "\x00", "")
  strOutput = Replace(strOutput, Chr(96), Chr(39)) ' ' > .
  'strOutput = Replace(strOutput, Chr(39), Chr(46)) ' ' > .
  'strOutput = Replace(strOutput, Chr(44), Chr(46)) ' , > .

  Return strOutput

End

Public Function Chek4SQL(strInput As String) As String ''Devuelve un texto apto para consulatas SQL, quita los saltos del línea y los caracteres no compatibles con sentencias SQL.

  Dim strOutput As String

  strOutput = Replace(strInput, "\n", "")
  strOutput = Replace(strOutput, "\r", "")
  strOutput = Replace(strOutput, "\x00", "")
  strOutput = Replace(strOutput, Chr(39), Chr(46)) ' ' > .
  strOutput = Replace(strOutput, Chr(44), Chr(46)) ' , > .

  Return strOutput

End

Public Function getTables(connDB As Connection, Optional strMod As String) As String[] ''Extraccion de la lista de tablas de la conexión. s ele pasan dos parametros, la conexión a la base de datos y el tipo view|table

  Dim strEngine As String
  Dim strSQL As String
  Dim resSQL As Result
  Dim stxSQL As New String[]
  Dim strTable As Variant

  strEngine = connDB.Type

  Select String.LCase(strMod)
    Case "", "table", "tables", "tabla", "tablas"
      strMod = "table"
    Case "view", "views", "vista", "vistas"
      strMod = "view"
  End Select

  If strEngine <> "" Then
    Select strEngine
      Case "sqlite3"
        strSQL = "SELECT name FROM sqlite_master WHERE type='" & strMod & "'"
        resSQL = connDB.Exec(strSQL)
        While resSQL.Available
          strTable = resSQL["name"]
          Select strTable
            Case "sqlite_sequence"
              '
            Case Else
              stxSQL.Add(strTable)
          End Select
          resSQL.MoveNext
        Wend
    End Select

  Endif
  stxSQL.Sort

  Return stxSQL

End

Public Function getFieldInfo(connDB As Connection, strTab As String, strFld As String) As String[]

  Dim strSQLk As String
  Dim resDBk As Result
  Dim strSentenceSQL As String
  Dim strSentence As String
  Dim stxSentence As New String[]
  Dim strFDOrigin As String
  Dim strTBReference As String
  Dim strFDReference As String
  Dim tblReference As Table
  Dim strFDShow As String
  Dim stxRefFields As New String[]
  Dim fldReference As Field
  Dim stxFieldInfo As New String[]
  Dim intSnt As Integer

  Dim stxWordsSQLite As New String[]
  Dim stxYesSQLite As New String[]
  Dim stxNotSQLite As New String[]
  Dim inxKeySQLite As New Integer[]
  Dim intWrd As Integer
  Dim intkey As Integer

  Select connDB.Type

    Case "sqlite3"

      stxWordsSQLite.Add("unique")
      stxYesSQLite.Add("YU")
      stxNotSQLite.Add("NU")
      inxKeySQLite.Add(0)

      stxWordsSQLite.Add("not null")
      stxYesSQLite.Add("NN")
      stxNotSQLite.Add("YN")
      inxKeySQLite.Add(1)

      stxWordsSQLite.Add("primary key")
      stxYesSQLite.Add("YK")
      stxNotSQLite.Add("NK")
      inxKeySQLite.Add(2)

      stxWordsSQLite.Add("autoincrement")
      stxYesSQLite.Add("YA")
      stxNotSQLite.Add("NA")

      inxKeySQLite.Add(3)

      strSQLk = "SELECT * FROM sqlite_master WHERE type='table' AND name='" & strTab & "'"
      resDBk = connDB.Exec(strSQLk)

      strSentenceSQL = Str(resDBk["sql"])
      stxSentence = Split(strSentenceSQL, "\n")

      If connDB.Opened Then
        If resDBk.Available Then

          resDBk.MoveFirst

          stxFieldInfo.Clear
          stxFieldInfo = ["", "", "", "", "", "", ""]

          For intSnt = 0 To stxSentence.Max
            If InStr(stxSentence[intSnt], "FOREIGN KEY") = 0 And InStr(stxSentence[intSnt], strFld) > 0 Then

              strSentence = Replace(stxSentence[intSnt], "\t`", "")
              strSentence = Replace(strSentence, strFld & "`", "")
              strSentence = Replace(strSentence, "\t", "")

              For intWrd = 0 To stxWordsSQLite.Max

                intkey = inxKeySQLite[intWrd]

                If InStr(String.LCase(stxSentence[intSnt]), stxWordsSQLite[intWrd]) > 0 Then
                  stxFieldInfo[intkey] = stxYesSQLite[intWrd]
                Else
                  stxFieldInfo[intkey] = stxNotSQLite[intWrd]
                Endif
              Next

              Break
            Endif
          Next

          For intSnt = 0 To stxSentence.Max
            If InStr(stxSentence[intSnt], "FOREIGN KEY") > 0 And InStr(stxSentence[intSnt], strFld) > 0 Then

              strSentence = Replace(stxSentence[intSnt], "\tFOREIGN KEY(`", "")
              strSentence = Replace(strSentence, "`) REFERENCES ", "~")
              strSentence = Replace(strSentence, " ( ", "~")
              strSentence = Replace(strSentence, " ),", " )")
              strSentence = Replace(strSentence, " )", "")
              strSentence = Replace(strSentence, "`", "")
              strSentence = Replace(strSentence, " ", "")

              strFDOrigin = Split(strSentence, "~")[0]
              strTBReference = Split(strSentence, "~")[1]
              strFDReference = Split(strSentence, "~")[2]
              ' Busco los campos de destino posibles

              tblReference = connDB.Tables[strTBReference]
              stxRefFields.Clear

              If tblReference.Fields.Count > 1 Then

                For Each fldReference In tblReference.Fields

                  stxRefFields.Add(fldReference.Name)

                Next

                If stxRefFields.Count > 1 Then
                  strFDShow = stxRefFields[1]
                Else
                  strFDShow = strFDReference
                Endif

              Endif

              stxFieldInfo[4] = strTBReference
              stxFieldInfo[5] = strFDReference
              stxFieldInfo[6] = strFDShow

              Break
            Endif
          Next

        Endif
      Endif

  End Select
  '---------------------------------------------------------------------------------
  Return stxFieldInfo

End

Public Function getIndex(connDB As Connection, strTab As String) As String[]

  Dim strSQLk As String
  Dim resDBk As Result
  '  Dim strSentenceSQL As String
  Dim strSentence As String
  Dim stxSentence As New String[]
  '  Dim strFDOrigin As String
  '  Dim strTBReference As String
  '  Dim strFDReference As String
  '  Dim tblReference As Table
  '  Dim strFDShow As String
  '  Dim stxRefFields As New String[]
  '  Dim fldReference As Field
  Dim stxIndex As New String[]
  Dim intSnt As Integer

  '  Dim stxWordsSQLite As New String[]
  '  Dim stxYesSQLite As New String[]
  '  Dim stxNotSQLite As New String[]
  '  Dim inxKeySQLite As New Integer[]
  '  Dim intWrd As Integer
  '  Dim intkey As Integer
  Dim intPos1 As Integer
  Dim intPos2 As Integer
  Dim intFi As Integer
  Dim stxTmp As New String[]

  Select connDB.Type

    Case "sqlite3"

      strSQLk = "SELECT * FROM sqlite_master WHERE type='index' AND tbl_name='" & strTab & "'  AND sql<>''"
      resDBk = connDB.Exec(strSQLk)

      If resDBk.Available Then

        resDBk.MoveFirst

        stxIndex.Clear
        stxIndex = ["", ""]

        For intSnt = 0 To stxSentence.Max
          If InStr(stxSentence[intSnt], "CREATE UNIQUE INDEX") > 0 And InStr(stxSentence[intSnt], strTab) > 0 Then

            intPos1 = InStr(stxSentence[intSnt], "(", 1)
            intPos2 = InStr(stxSentence[intSnt], ")", intPos1)

            strSentence = String.Mid(stxSentence[intSnt], intPos1, intPos2 - intPos1)
            strSentence = Replace(stxSentence, "ASC", "")
            strSentence = Replace(strSentence, "DESC", "")
            strSentence = Replace(strSentence, " ", "")

            stxTmp = Split(strSentence, ",")

            For intFi = 0 To stxTmp.Max

              'stxTmp[int]

            Next

          Endif
        Next
      Endif
  End Select

  Return stxIndex

End

Public Function getTableFields(connDB As Connection, strTab As String) As String[][] ''<p>Extraccion de la informacion de la estructura de una tabla.</p> <ol type="0">  <li>Nombre de la tabla</li>  <li>Nombre del campo</li>  <li>Tipo de campo</li>  <li>Valores únicos</li>  <li>Valores nulos</li>  <li>Clave primaria</li>  <li>Auto incremento</li></ol>

  Dim strSQLk As String
  Dim resDBk As Result
  Dim strSentenceSQL As String
  Dim strSentence As String
  Dim stxSentence As New String[]
  Dim strFDOrigin As String
  Dim strTBReference As String
  Dim strFDReference As String
  Dim tblReference As Table
  Dim strFDShow As String
  Dim stxRefFields As New String[]
  Dim fldReference As Field
  Dim tbl As Table
  Dim fld As Field
  Dim stxFieldInfo As New String[]
  Dim intSnt As Integer

  Dim stxWordsSQLite As New String[]
  Dim stxYesSQLite As New String[]
  Dim stxNotSQLite As New String[]
  Dim inxKeySQLite As New Integer[]
  Dim intWrd As Integer
  Dim intkey As Integer

  Dim stxTableInfo As New String[][]

  Select connDB.Type

    Case "sqlite3"

      stxWordsSQLite.Add("unique")
      stxYesSQLite.Add("YU")
      stxNotSQLite.Add("NU")
      inxKeySQLite.Add(3)

      stxWordsSQLite.Add("not null")
      stxYesSQLite.Add("NN")
      stxNotSQLite.Add("YN")
      inxKeySQLite.Add(4)

      stxWordsSQLite.Add("primary key")
      stxYesSQLite.Add("YK")
      stxNotSQLite.Add("NK")
      inxKeySQLite.Add(5)

      stxWordsSQLite.Add("autoincrement")
      stxYesSQLite.Add("YA")
      stxNotSQLite.Add("NA")

      inxKeySQLite.Add(6)

      strSQLk = "SELECT * FROM sqlite_master WHERE type='table' AND name='" & strTab & "'"
      resDBk = connDB.Exec(strSQLk)
      strSentenceSQL = Str(resDBk["sql"])
      stxSentence = Split(strSentenceSQL, "\n")

      If connDB.Opened Then
        If resDBk.Available Then

          resDBk.MoveFirst

          tbl = connDB.Tables[strTab]

          For Each fld In tbl.Fields

            stxFieldInfo.Clear
            stxFieldInfo = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]

            stxFieldInfo[0] = strTab
            stxFieldInfo[1] = fld.Name
            stxFieldInfo[2] = String.LCase(GEFUtility.TypeVar(fld.Type))
            'stxFieldInfo[3] = ""
            'stxFieldInfo[4] = ""
            'stxFieldInfo[5] = ""
            'stxFieldInfo[6] = ""
            stxFieldInfo[7] = ""
            stxFieldInfo[8] = ""
            stxFieldInfo[9] = ""

            '----------------------------------------------------------------------------------
            For intSnt = 0 To stxSentence.Max
              If InStr(stxSentence[intSnt], "FOREIGN KEY") = 0 And InStr(stxSentence[intSnt], fld.Name) > 0 Then
                Print stxSentence[intSnt] & " Datos del campo"

                strSentence = Replace(stxSentence[intSnt], "\t`", "")
                strSentence = Replace(strSentence, fld.Name & "`", "")
                strSentence = Replace(strSentence, "\t", "")

                Print strSentence & " Datos del campo proc"

                For intWrd = 0 To stxWordsSQLite.Max

                  intkey = inxKeySQLite[intWrd]

                  If InStr(String.LCase(stxSentence[intSnt]), stxWordsSQLite[intWrd]) > 0 Then
                    stxFieldInfo[intkey] = stxYesSQLite[intWrd]
                  Else
                    stxFieldInfo[intkey] = stxNotSQLite[intWrd]
                  Endif
                Next

                Break
              Endif
            Next

            For intSnt = 0 To stxSentence.Max
              If InStr(stxSentence[intSnt], "FOREIGN KEY") > 0 And InStr(stxSentence[intSnt], fld.Name) > 0 Then
                Print stxSentence[intSnt] & " Datos del foráneo"

                strSentence = Replace(stxSentence[intSnt], "\tFOREIGN KEY(`", "")
                strSentence = Replace(strSentence, "`) REFERENCES ", "~")
                strSentence = Replace(strSentence, " ( ", "~")
                strSentence = Replace(strSentence, " ),", " )")
                strSentence = Replace(strSentence, " )", "")
                strSentence = Replace(strSentence, "`", "")
                strSentence = Replace(strSentence, " ", "")

                strFDOrigin = Split(strSentence, "~")[0]
                strTBReference = Split(strSentence, "~")[1]
                strFDReference = Split(strSentence, "~")[2]
                ' Busco los campos de destino posibles

                tblReference = connDB.Tables[strTBReference]
                stxRefFields.Clear

                If tblReference.Fields.Count > 1 Then

                  For Each fldReference In tblReference.Fields
                    stxRefFields.Add(fldReference.Name)
                  Next

                  If stxRefFields.Count > 1 Then
                    strFDShow = stxRefFields[1]
                  Else
                    strFDShow = strFDReference
                  Endif
                Endif

                stxFieldInfo[7] = strTBReference
                stxFieldInfo[8] = strFDReference
                stxFieldInfo[9] = strFDShow

                Break
              Endif
            Next
            '----------------------------------------------------------------------------------
            ' Agregando a la matriz de salida
            'stxTableInfo.Add(stxFieldInfo.Join(":"))
            stxTableInfo.Add(stxFieldInfo)

          Next
        Endif
      Endif
      'Case "postgres"
      'Case "mysql"
      'Case "odbc"

  End Select
  '---------------------------------------------------------------------------------
  Return stxTableInfo

End

Public Function getViewFields(connDB As Connection, strView As String) As String[][] ''Extraccion de la informacion de la estructura de una vista.

  Dim strSQLk As String
  Dim resDBk As Result
  Dim intord As Integer
  Dim fld As ResultField
  Dim stxFieldInfo As New String[]
  Dim stxTableInfo As New String[][]
  Dim intOrder As Variant
  Dim strOrder As Variant
  Dim strOrderTmp As Variant

  Select connDB.Type

    Case "sqlite3"

      strSQLk = "SELECT * FROM " & strView
      resDBk = connDB.Exec(strSQLk)

      If connDB.Opened Then
        If resDBk.Available Then

          resDBk.MoveFirst
          intOrd = 0
          For Each fld In resDBk.Fields
            stxFieldInfo.Clear
            stxFieldInfo = ["0", "1", "2", "3", "4", "5", "6"]

            stxFieldInfo[0] = strView
            stxFieldInfo[1] = fld.Name
            stxFieldInfo[2] = String.LCase(GEFUtility.TypeVar(fld.Type))
            stxFieldInfo[3] = CStr(intOrd) ' Numero de columna

            strOrderTmp = Settings[strView & "-order/" & CStr(intOrd), ""]

            intOrder = ""
            strOrder = ""

            stxFieldInfo[4] = CStr(intOrder) ' Tipo de filtro

            'stxTableInfo.Add(stxFieldInfo.Join(":"))
            stxTableInfo.Add(stxFieldInfo)

            Inc intOrd

          Next
        Endif
      Endif
      'Case "postgres"
      'Case "mysql"
      'Case "odbc"

  End Select
  '---------------------------------------------------------------------------------
  Return stxTableInfo

End

Public Function RecordExist(connDB As Connection, strTable As String, strFieldVal As String, strFieldKey As String, strValue As String) As Integer ''Devuelve -1 si no existe o un numero (la clave) si existe el texto que se pasa como parametro junto con la tabla y el campo.

  Dim strSQLCheck As String
  Dim resCheckRef As Result
  Dim intKey As Integer

  strSQLCheck = "select "
  strSQLCheck &= strFieldVal & ", " & strFieldKey
  strSQLCheck &= " from " & strTable
  strSQLCheck &= " where " & strFieldVal & "='"
  strSQLCheck &= strValue & "'"

  resCheckRef = connDB.Exec(strSQLCheck)

  If resCheckRef.Available Then
    If resCheckRef.Count > 0 Then
      intKey = resCheckRef[strFieldKey]
    Else
      intKey = -1
    Endif
  Else
    intKey = -1
  Endif
  Return intKey

End

Public Function RecordDelete(connDB As Connection, strTable As String, stxDBFields As String[][], intKey As Integer) As Integer ''Devuelve -1 si no existe o un numero (la clave) si existe el texto que se pasa como parametro junto con la tabla y el campo.

  Dim strSQLDelete As String
  Dim resCheck As Result
  Dim intField As Integer
  Dim strFieldKey As String

  For intField = 0 To stxDBFields.Max
    If stxDBFields[intField][0] = strTable Then
      If stxDBFields[intField][5] = "YK" Then
        strFieldKey = stxDBFields[intField][1]
        Break
      Endif
    Endif
  Next

  connDB.Delete(strTable, strFieldKey & "=&1", intKey)

  ' Verificación
  strSQLDelete = "select *"
  strSQLDelete &= " from " & strTable
  strSQLDelete &= " where " & strFieldKey & "='"
  strSQLDelete &= CStr(intKey) & "'"

  resCheck = connDB.Exec(strSQLDelete)

  If resCheck.Available Then
    If resCheck.Count > 0 Then
      intKey = resCheck[strFieldKey]
    Else
      intKey = -1
    Endif
  Else
    intKey = -1
  Endif

  Return intKey

End

Public Function SqlMake(strTbl As String, stxFld As String[][]) As String

  Dim int As Integer
  Dim strSqlOut As String
  Dim stxOrder As New String[]
  Dim strOrder As String
  Dim stxFilter As New String[]
  Dim strFilter As String

  strSqlOut = "select * from " & strTbl

  For int = 0 To stxFld.Max

    If stxFld[int][0] = strTbl Then
      'Acopiar los ordenes que existan
      Select stxFld[int][3]
        Case "asc", "desc"
          stxOrder.Push(stxFld[int][1] & " " & stxFld[int][3])
      End Select

      'Acopiar los filtros que existan
      Select stxFld[int][4]
        Case "=", "<>", ">", "<", ">=", "<="
          stxFilter.Push(stxFld[int][1] & stxFld[int][4] & "'" & stxFld[int][5] & "'")
        Case "like", "not like" ', "in"
          stxFilter.Push(stxFld[int][1] & " " & stxFld[int][4] & " '%" & stxFld[int][5] & "%'")
      End Select

    Endif
  Next

  Select stxFilter.Count
    Case 0
      strFilter = ""
    Case 1
      strFilter = " where " & stxOrder[0]
    Case Else
      strFilter = " where " & stxOrder.Join(" and ")
  End Select
  strSqlOut &= strFilter

  Select stxOrder.Count
    Case 0
      strOrder = ""
    Case 1
      strOrder = " order by " & stxOrder[0]
    Case Else
      strOrder = " order by " & stxOrder.Join(", ")

  End Select
  strSqlOut &= strOrder

  Return strSqlOut

End

Public Function TableMake1(cnx As Connection, stxParam As String[]) As Integer ''<p>Crea una tabla en la conexion que se le pasa como parametro. Donde el orden de los paramentros dentro de la matriz debe ser el siguiente:</p><ul><li>0 Nombre de la tabla</li><li>1 Nombre del campo clave</li><li>2 Nombre del resto de los campos</li><li>N Nombre del ultimo campo</li></ul>

  Dim tbl As Table
  Dim int As Integer
  Dim strFKey As String 'Nombre del campo que sera Primary Key
  Dim strFIdx As String 'Nombre del campo indice para esta funsion sera uno solo, el siguiente al campo PK.
  Dim strFNme As String 'Nombre cambiante del resto de los campos.

  If cnx.Tables.Exist(stxParam[0]) = False Then
    cnx.Tables.Add(stxParam[0])
    tbl = cnx.Tables[stxParam[0]]
    With tbl
      For int = 1 To stxParam.Max
        Select int
          Case 1
            strFKey = stxParam[0] & stxParam[int]
            tbl.Fields.Add(strFKey, db.Serial)
          Case 2
            strFIdx = stxParam[0] & stxParam[int]
            tbl.Fields.Add(strFIdx, db.String)
          Case Else
            strFNme = stxParam[0] & stxParam[int]
            tbl.Fields.Add(strFNme, db.String)
        End Select
      Next
      tbl.PrimaryKey = [strFKey]
      tbl.Update()
      tbl.Indexes.Add(stxParam[0] & "_idx", [strFIdx], True)
    End With

  Endif

  If cnx.Tables.Exist(stxParam[0]) = True Then
    Return 1
  Else
    Return 0
  Endif

End

Public Function TableMake2(cnx As Connection, stxParam As String[]) As Integer ''<p>Crea una tabla de combinacion de otras dos tablas en la conexion que se le pasa como parametro. Donde el orden de los paramentros dentro de la matriz debe ser el siguiente:</p><ul><li>0 Nombre de la tabla 1</li><li>1 Nombre del campo clave 1</li><li>2 Nombre del campo a mostrar 1</li><li>3 Nombre de la tabla 21</li><li>4 Nombre del campo clave 2</li><li>5 Nombre del campo a mostrar 2</li></ul>

  Dim tbl As Table
  '  Dim int As Integer
  Dim strTable As String
  Dim strFKey As String 'Nombre del campo que sera Primary Key

  Dim strFld1 As String 'Nombre del campo 1
  Dim strTblf1 As String 'Nombre de la tabla foránea 1
  Dim strFIdx1 As String 'Nombre del campo indice en la tabla foránea 1
  Dim strFShw1 As String 'Nombre del campo a mostrar en la tabla foránea 1

  Dim strFld2 As String 'Nombre del campo 2
  Dim strTblf2 As String 'Nombre de la tabla foránea 2
  Dim strFIdx2 As String 'Nombre del campo indice en la tabla foránea 2
  Dim strFShw2 As String 'Nombre del campo a mostrar en la tabla foránea 2

  strTable = stxParam[0] & stxParam[3]
  strFKey = strTable & "i"

  strFld1 = strTable & "1"
  strTblf1 = stxParam[0]
  strFIdx1 = stxParam[1]
  strFShw1 = stxParam[2]

  strFld2 = strTable & "2"
  strTblf2 = stxParam[3]
  strFIdx2 = stxParam[4]
  strFShw2 = stxParam[5]

  If cnx.Tables.Exist(strTable) = False Then
    cnx.Tables.Add(strTable)
    tbl = cnx.Tables[strTable]

    With tbl
      tbl.Fields.Add(strFKey, db.Serial)
      tbl.Fields.Add(strFld1, db.Integer)
      tbl.Fields.Add(strFld2, db.Integer)

      tbl.PrimaryKey = [strFKey]

      tbl.Update()

      tbl.Indexes.Add(strTable & "_idx", [strFld1], True)

    End With
  Endif

  If cnx.Tables.Exist(strTable) = True Then
    Return 1
  Else
    Return 0
  Endif

End

Public Function ViewMake1(cnx As Connection, stxParam As String[]) As Integer ''Crea una Vista en la conexion que se le pasa como parametro. La funcion trabaja con campos que se llaman TABLA+i y TABLA+n donde n es un numero correlativo. Todos los vinculas seran left join y el orden sera por la segunda columna. Por ejemplo para una tabla de productos donde hay un campo color y otro clase y ambos son tablas relacionadas. Donde el orden de los paramentros dentro de la matriz debe ser el siguiente: <ul><li>0 Nombre de la tabla base</li><li>1 Este y en adelante, nombre las tablas secundarias</li></ul>Para el ejemplo<ul><li>0 productos</li><li>1 color</li><li>2 clase</li></ul><p>Donde color tendra los campos colori, color1 y clase tendrá los campos clasei, clase1. La tabla principal tendra los campos productosi, productos1, productos2

  Dim ptbl As Table
  Dim strType As String
  Dim stxTb As New String[]
  Dim strTb As String
  Dim strFx As String
  Dim strFs As String

  Dim stxFinfo As New String[]
  Dim stxHeader As New String[]
  Dim stxFields As New String[]
  Dim stxJoints As New String[]
  Dim stxOrders As New String[]

  Dim strCreate As String
  Dim fld As Field
  Dim strEnd As String
  Dim intfld As Integer
  Dim intX As Integer

  strType = cnx.Type
  ptbl = cnx.Tables[stxParam[0]]
  ' "postgresql"
  ' "mysql"
  ' "sqlite2"
  ' "sqlite3"
  ' "sqlite"
  ' "odbc"
  stxHeader.Clear
  stxFields.Clear
  stxJoints.Clear
  stxOrders.Clear
  stxHeader.Add("CREATE VIEW `" & "v" & stxParam[0] & "` AS SELECT\n")
  With ptbl
    intfld = 0
    For Each fld In .Fields

      ' If intFld = .Fields.Count - 1 Then
      '   strEnd = ""
      ' Else
      '   strEnd = ","
      ' Endif
      Select .PrimaryKey.Find(fld.Name)
        Case 0 'es la primera clave el resto, si las hubiera, se destartan
          stxFields.Add(fld.Name & strEnd)
          stxTb.Add(String.Mid(fld.Name, 1, 2))
          stxTb.Add(String.Mid(fld.Name, 3, 2))

        Case Else

          Select fld.Type
            Case db.Integer
              'stxFinfo = getFieldInfo(cnx, stxParam[0], fld.Name)
              'Esto esta manual porque no logre poner foreign keys por código

              strTb = stxTb[intX]
              strFx = strTb & "i"
              strFs = strTb & "1"
              Inc intX
              stxFinfo = ["", "", "", "", strTb, strFx, strFs]

              If stxFinfo[4] <> "" Then
                stxFields.Add(stxFinfo[6] & " AS " & fld.Name)
                stxFields.Add(stxFinfo[5])
                stxJoints.Add("LEFT JOIN " & stxFinfo[4] & " ON " & fld.Name & "=" & stxFinfo[5])
                stxOrders.Add(fld.Name)
              Else
                stxFields.Add(fld.Name)
              Endif
            Case Else
              stxFields.Add(fld.Name)
          End Select
      End Select
      Inc intfld

    Next
  End With
  strCreate = stxHeader.Join("\n")
  strCreate &= stxFields.Join(",\n")
  strCreate &= "\n"
  strCreate &= "FROM " & stxParam[0] & "\n"
  strCreate &= stxJoints.Join("\n")
  strCreate &= "\n"
  strCreate &= "ORDER BY " & stxOrders.Join(", ")
  'strCreate &= "\n"
  'strCreate &= ")"

  cnx.Exec(strCreate)

End

Public Function RecordNewTest(cnx As Connection, strTbl As String, stxIns As String[][]) As Integer ''Inserta un registro nuevo en la base de datos.

  Dim resIns As Result
  Dim int As Integer
  Dim strSQL As String
  Dim res As Result

  strSQL = "select " & stxIns[int][0] &
    " from " & strTbl &
    " where " & stxIns[int][0] &
    "='" & stxIns[int][1] & "'"
  res = cnx.Exec(strSQL)

  If res.Count = 0 Then ' Esto es para evitar insertar un registro que ya existe
    If stxIns.Count > 0 Then
      resIns = cnx.Create(strTbl)
      For int = 0 To stxIns.Max
        resIns[stxIns[int][0]] = stxIns[int][1]
      Next
      resIns.Update
    Endif
  Endif

End

Public Function RecordNewRefTest(cnx As Connection, stxTbl As String[], stxIns As String[][]) As Integer ''Inserta un registro nuevo en la base de datos.

  Dim resIns As Result
  Dim int As Integer
  Dim strSQL As String
  Dim res As Result
  Dim fld As ResultField
  Dim strRef As String

  Dim strChk As String
  Dim resChk As Result

  strSQL = "select * " &
    " from " & stxTbl[1] &
    " where " & stxTbl[2] &
    "='" & stxIns[int][1] & "'"
  res = cnx.Exec(strSQL)

  For Each fld In res.Fields
    Select fld.Type
      Case db.Integer, db.Serial
        strRef = fld.Name
    End Select
  Next

  strChk = "select * " &
    " from " & stxTbl[0] &
    " where " & stxIns[int][0] &
    "='" & res[strRef] & "'"
  resChk = cnx.Exec(strChk)

  If resChk.Count = 0 Then ' Esto es para evitar insertar un registro que ya existe
    If stxIns.Count > 0 Then
      resIns = cnx.Create(stxTbl[0])
      For int = 0 To stxIns.Max
        resIns[stxIns[int][0]] = res[strRef]
        Print stxIns[int][0] & ": " & res[strRef]
      Next
    Endif
    resIns.Update
  Endif

End

Public Function RecordEdit(connDB As Connection, strTable As String, stxValues As String[]) As Integer '' Inserta un registro nuevo en la base de datos, ctnVal es una coleccion opcional del pares de campo:valor.

  Dim intVal As Integer
  Dim strTag As String
  Dim strVal As String
  Dim stxTag As New String[]
  Dim stxVal As New String[]
  Dim strKey As String
  Dim intKey As Integer
  Dim resEdit As Result
  Dim int As Integer

  For int = 0 To GEFStarter.stxTableFields.Max
    If GEFStarter.stxTableFields[int][0] = strTable Then
      If GEFStarter.stxTableFields[int][5] = "YK" Then
        strKey = GEFStarter.stxTableFields[int][1]
      Endif
    Endif
  Next

  If stxValues.Count > 0 Then
    For intVal = 0 To stxValues.Max
      strTag = Split(stxValues[intVal], "\t")[0]
      strVal = Split(stxValues[intVal], "\t")[1]
      stxTag.Add(strTag)
      stxVal.Add(strVal)

      If strTag = strKey Then
        intKey = CInt(strVal)
        'Break
      Endif
    Next
  Endif

  resEdit = connDB.Edit(strTable, strKey & "=&1", intkey)

  For int = 0 To stxTag.Max

    strTag = stxTag[int]
    strVal = stxVal[int]

    If resEdit[strTag] <> strVal Then
      resEdit[strTag] = strVal
    Endif

  Next

  resEdit.Update

End

Public Sub MDBtoSQL(strFilePath As String) As String[] ''Estadisticas de bases de datos .mdb usando mdbtools. Como parametro de entrada precisa la ruta completa del archivo .mdb Dependencias: mdbtools DB.V.T.Bytes TB.R.C.Bytes

  Dim strTools As String
  Dim strPkg As String
  Dim strStatVersion As String
  Dim strStatTables As String
  Dim strStatTable As String
  Dim intW, intQtyTb, intBytes As Integer
  Dim stxStatTablesTmp As New String[]
  Dim stxStatTables As New String[]
  Dim stxStatFieldsTmp As New String[]
  Dim strStatFieldLine As String
  Dim strStatFieldsTable As String
  Dim strStatFieldsTitle As String
  Dim strStatFieldsType As String
  Dim stxStatFields As New String[]
  Dim stxDatabaseInfo As New String[]
  Dim strJobName As String
  Dim strJobPath As String ' Directorio de trabajo en Home
  Dim strFinalPath As String ' Directorio de destino para el sqlite generado
  Dim strFileExt As String ' Archivo de esxtraccion en bruto
  Dim strFileSQL As String ' Archivo con la sentencia sql listo para importar
  Dim prsQ1, prsQ2, prsQ3 As Process
  Dim prsA, prsB, prsC As Process
  Dim strFilePathPerm As String

  stxStatTablesTmp.Clear
  stxStatTables.Clear
  stxStatFieldsTmp.Clear
  stxStatFields.Clear
  stxDatabaseInfo.Clear

  ' Primera verificación ¿El paquete mdbtools esta instalado en el sistema?
  strPkg = "mdbtools"
  strTools = GEFSys.PkgStat(strPkg)

  Print "mdbtools " & ("instalado correctamente")

  ' Es el nombre de la base de datos sin el .mdb o .accdb
  strJobName = String.LCase(File.BaseName(strFilePath))
  strJobName = Replace(strJobName, " ", "-")
  strJobName = Replace(strJobName, "--", "-")

  strFilePathPerm = Stat(File.Dir(strFilePath)).Perm[User.Name]

  strJobPath = User.Home &/ ".databases" &/ strJobName

  Select InStr(strFilePathPerm, "w") ' Verificacion de que existe permisos de escritura
    Case 0 ' No se tienen permisos de escritura > se escoge el directorio home del usuario
      strFinalPath = strJobPath
    Case Else
      strFinalPath = File.Dir(strFilePath)
  End Select

  Print strJobPath

  If Exist(strJobPath) = False Then
    Shell "mkdir -p '" & strJobPath & "'"
  Endif

  'Extracción de los nombres de las tablas
  Shell "mdb-ver '" & strFilePath & "' 2>&1" To strStatVersion
  strStatVersion = Replace(strStatVersion, "\n", "")

  Print strStatVersion

  Shell "mdb-tables -S -1 '" & strFilePath & "' 2>&1" To strStatTables

  'Extracción de esquemas
  prsQ1 = Shell "mdb-schema '" & strFilePath & "' postgres > '" & strJobPath &/ strJobName & "-sch-postgres.sql'"
  While prsQ1.State = prsQ1.Running
    Wait 0.1
  Wend

  prsQ2 = Shell "mdb-schema '" & strFilePath & "' mysql > '" & strJobPath &/ strJobName & "-sch-mysql.sql'"
  While prsQ2.State = prsQ2.Running
    Wait 0.1
  Wend

  prsQ3 = Shell "mdb-schema '" & strFilePath & "' sqlite > '" & strJobPath &/ strJobName & "-sch-sqlite.sql'"
  While prsQ3.State = prsQ3.Running
    Wait 0.1
  Wend

  Print ("Esquemas extraídos")

  stxStatFieldsTmp = Split(File.Load(strJobPath &/ strJobName & "-sch-postgres.sql"), "\n")

  For Each strStatFieldLine In stxStatFieldsTmp

    Select String.Mid(strStatFieldLine, 1, 2)
      Case "CR" ' Comienzo de la tabla
        strStatFieldsTable = Split(strStatFieldLine, Chr(34))[1]
      Case "\t" & Chr(34) ' Nombre y tipo de campo

        strStatFieldsTitle = Split(strStatFieldLine, Chr(34))[1]
        strStatFieldsType = Split(strStatFieldLine, Chr(34))[2]
        strStatFieldsType = Replace(strStatFieldsType, ",", "")
        strStatFieldsType = Replace(strStatFieldsType, "\t", "")

        stxStatFields.Add(strStatFieldsTable & "." & strStatFieldsTitle & "." & strStatFieldsType)

    End Select

  Next

  Print ("Nombres de campos cargados")

  File.Save(strJobPath &/ "fields.txt", stxStatFields.Join("\n"))

  Print stxStatFields.Join("\n")

  'Extracción de los nombres de las tablas
  prsA = Shell "mdb-tables -S -1 '" & strFilePath & "' > '" & strJobPath &/ "tables.txt'"

  While prsA.State = prsA.Running
    Wait 0.1
  Wend

  Print ("Nombres de tablas cargados")

  'Filtrado y ordenamiento de la lista de tablas
  If strStatTables <> "" Then

    'stxStatTablesTmp.Clear
    'stxDatabaseInfo.Clear

    stxStatTablesTmp = Split(strStatTables, "\n")
    stxStatTablesTmp.Sort

    'Agregado a la matriz de la version de la base de datos [0]
    stxDatabaseInfo.Add(strStatVersion)

    ' Ordenamiento de las tablas
    For intW = 0 To stxStatTablesTmp.Max
      strStatTable = stxStatTablesTmp[intW]
      If Mid(strStatTable, 1, 4) <> "MSys" Then
        If strStatTable <> "" Then
          If InStr(strStatTable, " ") = 0 Then
            stxStatTables.Add(strStatTable)
          Endif
        Endif
      Endif
    Next
  Endif
  ' Agregado a la matriz de la cantidad de tablas [1]
  intQtyTb = stxStatTables.Count
  stxDatabaseInfo.Add(Str(intQtyTb))
  ' Agregado a la matriz de la cantidad de tablas [2]
  intBytes = Stat(strFilePath).Size
  stxDatabaseInfo.Add(Str(intBytes))
  ' Agregado a la matriz del directorio de trabajo [3]
  stxDatabaseInfo.Add(strJobPath)
  ' Agregado a la matriz el nombre del .sqlite [4]
  stxDatabaseInfo.Add(strJobName & ".sqlite")
  ' Agregado a la matriz del directorio de destino [5]
  stxDatabaseInfo.Add(strFinalPath)

  ' Agregado a la matriz de la cantidad de tablas [6:X]
  For Each strStatTable In stxStatTables

    stxDatabaseInfo.Add(strStatTable)

    strFileExt = strJobPath &/ strStatTable & ".tmp"
    strFileSQL = strJobPath &/ strStatTable & "-data.sql"

    prsB = Shell "mdb-export -D %Y%m%d%H%M%S -H -b strip -R '::rrr::' -d '::ccc::' " & strFilePath & " " & strStatTable & " > " & strFileExt
    Exec ["notify-send", "-t", "2000", ("Sistema"), ("Extrayendo datos de") & " " & strStatTable]
    While prsB.State = prsB.Running

      Print ("Extrayendo datos de") & " " & strStatTable

      Wait 0.1
    Wend

    prsC = Shell "tr -cd '[:print:]' < " & strFileExt & " | tr -s ' ' | sed 's/\\d96//g' | sed 's/\\d39//g' | sed 's/,/~/g' | sed 's/\\d34/\\d39/g'  | sed 's/::ccc::::ccc::/::ccc::\\d39\\d39::ccc::/g' | sed 's/::ccc::::ccc::/::ccc::\\d39\\d39::ccc::/g' | sed 's/::ccc::::ccc::/::ccc::\\d39\\d39::ccc::/g' | sed 's/::rrr::/\\n/g' | sed '/^$/d' | sed -e 's/^/INSERT INTO `" & strStatTable & "` VALUES (/' | sed 's/.*/&);/' | sed 's/::ccc::\\d41;/::ccc::\\d39\\d39\\d41;/g' | sed 's/::ccc::/,/g' > " & strFileSQL
    Exec ["notify-send", "-t", "2000", ("Sistema"), ("Formateando datos de") & " " & strStatTable]
    While prsC.State = prsC.Running

      Print ("Formateando datos de") & " " & strStatTable
      Wait 0.1
    Wend

    Print "Ha finalizado exitosamente la extracción de datos de la tabla: " & strStatTable

  Next

  Exec ["notify-send", "-t", "2000", ("Sistema"), ("Base de datos completada")]

  ' Extraccion de los archivos csv de las tablas
  File.Save(strJobPath &/ "tables.txt", stxStatTables.Join("\n"))

  Print stxDatabaseInfo.Join("\n")

  Print ("Conversion terminada satisfactoriamente")

  Return stxDatabaseInfo

End

Public Function DataType(int As Integer) As String ''Devuelve el nombre del tipo de dato, la constante del gb.db <ul><li>-2 = Blob</li><li>-1 = Serial</li><li>1 = Boolean</li><li>2 = Serial</li><li>4 = Integer</li><li>5 = Long</li><li>7 = Float</li><li>8 = Date</li><li>9 = String</li></ul>

  Dim stx As New String[]
  Dim inx As New Integer[]
  Dim str As String
  Dim intKey As Integer

  inx.Add(-2)
  stx.Add("Blob")

  inx.Add(1)
  stx.Add("Boolean")

  inx.Add(8)
  stx.Add("Date")

  inx.Add(7)
  stx.Add("Float")

  inx.Add(4)
  stx.Add("Integer")

  inx.Add(5)
  stx.Add("Long")

  inx.Add(-1)
  stx.Add("Serial")

  inx.Add(9)
  stx.Add("String ")

  intKey = inx.Find(int)
  If intKey <> -1 Then
    str = stx[intKey]
  Else
    str = ""
  Endif

  Return str

End
